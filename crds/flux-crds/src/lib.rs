// Generated by:
// target/debug/k8s-crds-codegen

pub mod helm_toolkit_fluxcd_io {
    pub mod v2beta1 {
        pub mod helm_release {
            /// HelmRelease is the Schema for the helmreleases API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct HelmRelease {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for HelmRelease {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "helm.toolkit.fluxcd.io/v2beta1";
                const GROUP: &'static str = "helm.toolkit.fluxcd.io";
                const KIND: &'static str = "HelmRelease";
                const VERSION: &'static str = "v2beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for HelmRelease {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for HelmRelease {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("HelmRelease", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Chart defines the template of the v1beta2.HelmChart that should be created for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Chart {
                /// Spec holds the template for the v1beta2.HelmChartSpec for this HelmRelease.
                pub spec: ChartSpec,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// NamespacedObjectReference contains enough information to locate the referenced Kubernetes resource object in any namespace.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DependsOnItem {
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// Image contains an image name, a new name, a new tag or digest, which will replace the original name and tag.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImagesItem {
                /// Digest is the value used to replace the original image tag. If digest is present NewTag value is ignored.
                pub digest: String,
                /// Name is a tag-less image name.
                pub name: String,
                /// NewName is the value used to replace the original name.
                pub new_name: String,
                /// NewTag is the value used to replace the original tag.
                pub new_tag: String,
            }

            /// Install holds the configuration for Helm install actions for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Install {
                /// CRDs upgrade CRDs from the Helm Chart's crds directory according to the CRD upgrade policy provided here. Valid values are `Skip`, `Create` or `CreateReplace`. Default is `Create` and if omitted CRDs are installed but not updated.
                ///  Skip: do neither install nor replace (update) any CRDs.
                ///  Create: new CRDs are created, existing CRDs are neither updated nor deleted.
                ///  CreateReplace: new CRDs are created, existing CRDs are updated (replaced) but not deleted.
                ///  By default, CRDs are applied (installed) during Helm install action. With this option users can opt-in to CRD replace existing CRDs on Helm install actions, which is not (yet) natively supported by Helm. https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
                pub crds: String,
                /// CreateNamespace tells the Helm install action to create the HelmReleaseSpec.TargetNamespace if it does not exist yet. On uninstall, the namespace will not be garbage collected.
                pub create_namespace: bool,
                /// DisableHooks prevents hooks from running during the Helm install action.
                pub disable_hooks: bool,
                /// DisableOpenAPIValidation prevents the Helm install action from validating rendered templates against the Kubernetes OpenAPI Schema.
                pub disable_open_a_p_i_validation: bool,
                /// DisableWait disables the waiting for resources to be ready after a Helm install has been performed.
                pub disable_wait: bool,
                /// DisableWaitForJobs disables waiting for jobs to complete after a Helm install has been performed.
                pub disable_wait_for_jobs: bool,
                /// Remediation holds the remediation configuration for when the Helm install action for the HelmRelease fails. The default is to not perform any action.
                pub remediation: InstallRemediation,
                /// Replace tells the Helm install action to re-use the 'ReleaseName', but only if that name is a deleted release which remains in the history.
                pub replace: bool,
                /// SkipCRDs tells the Helm install action to not install any CRDs. By default, CRDs are installed if not already present.
                ///  Deprecated use CRD policy (`crds`) attribute with value `Skip` instead.
                pub skip_c_r_ds: bool,
                /// Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm install action. Defaults to 'HelmReleaseSpec.Timeout'.
                pub timeout: String,
            }

            /// KubeConfig for reconciling the HelmRelease on a remote cluster. When used in combination with HelmReleaseSpec.ServiceAccountName, forces the controller to act on behalf of that Service Account at the target cluster. If the --default-service-account flag is set, its value will be used as a controller level fallback for when HelmReleaseSpec.ServiceAccountName is empty.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubeConfig {
                /// SecretRef holds the name to a secret that contains a key with the kubeconfig file as the value. If no key is specified the key will default to 'value'. The secret must be in the same namespace as the HelmRelease. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the HelmRelease.
                pub secret_ref: SecretRef,
            }

            /// Kustomization to apply as PostRenderer.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Kustomize {
                /// Images is a list of (image name, new name, new tag or digest) for changing image names, tags or digests. This can also be achieved with a patch, but this operator is simpler to specify.
                pub images: Vec<ImagesItem>,
                /// Strategic merge and JSON patches, defined as inline YAML objects, capable of targeting objects based on kind, label and annotation selectors.
                pub patches: Vec<PatchesItem>,
                /// JSON 6902 patches, defined as inline YAML objects.
                pub patches_json6902: Vec<PatchesJson6902Item>,
                /// Strategic merge patches, defined as inline YAML objects.
                pub patches_strategic_merge: Vec<serde_json::Map<String, serde_json::Value>>,
            }

            /// JSON6902 is a JSON6902 operation object. https://datatracker.ietf.org/doc/html/rfc6902#section-4
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchItem {
                /// From contains a JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub from: String,
                /// Op indicates the operation to perform. Its value MUST be one of "add", "remove", "replace", "move", "copy", or "test". https://datatracker.ietf.org/doc/html/rfc6902#section-4
                pub op: String,
                /// Path contains the JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op.
                pub path: String,
                /// Value contains a valid JSON structure. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub value: serde_json::Map<String, serde_json::Value>,
            }

            /// Patch contains an inline StrategicMerge or JSON6902 patch, and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItem {
                /// Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with an array of operation objects.
                pub patch: String,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesItemTarget,
            }

            /// JSON6902Patch contains a JSON6902 patch and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902Item {
                /// Patch contains the JSON6902 patch document with an array of operation objects.
                pub patch: Vec<PatchItem>,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesJson6902ItemTarget,
            }

            /// PostRenderer contains a Helm PostRenderer specification.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PostRenderersItem {
                /// Kustomization to apply as PostRenderer.
                pub kustomize: Kustomize,
            }

            /// Remediation holds the remediation configuration for when the Helm install action for the HelmRelease fails. The default is to not perform any action.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct InstallRemediation {
                /// IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an install action but fail. Defaults to 'Test.IgnoreFailures'.
                pub ignore_test_failures: bool,
                /// RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to 'false'.
                pub remediate_last_failure: bool,
                /// Retries is the number of retries that should be attempted on failures before bailing. Remediation, using an uninstall, is performed between each attempt. Defaults to '0', a negative integer equals to unlimited retries.
                pub retries: i64,
            }

            /// Remediation holds the remediation configuration for when the Helm upgrade action for the HelmRelease fails. The default is to not perform any action.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct UpgradeRemediation {
                /// IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an upgrade action but fail. Defaults to 'Test.IgnoreFailures'.
                pub ignore_test_failures: bool,
                /// RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to 'false' unless 'Retries' is greater than 0.
                pub remediate_last_failure: bool,
                /// Retries is the number of retries that should be attempted on failures before bailing. Remediation, using 'Strategy', is performed between each attempt. Defaults to '0', a negative integer equals to unlimited retries.
                pub retries: i64,
                /// Strategy to use for failure remediation. Defaults to 'rollback'.
                pub strategy: String,
            }

            /// Rollback holds the configuration for Helm rollback actions for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Rollback {
                /// CleanupOnFail allows deletion of new resources created during the Helm rollback action when it fails.
                pub cleanup_on_fail: bool,
                /// DisableHooks prevents hooks from running during the Helm rollback action.
                pub disable_hooks: bool,
                /// DisableWait disables the waiting for resources to be ready after a Helm rollback has been performed.
                pub disable_wait: bool,
                /// DisableWaitForJobs disables waiting for jobs to complete after a Helm rollback has been performed.
                pub disable_wait_for_jobs: bool,
                /// Force forces resource updates through a replacement strategy.
                pub force: bool,
                /// Recreate performs pod restarts for the resource if applicable.
                pub recreate: bool,
                /// Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm rollback action. Defaults to 'HelmReleaseSpec.Timeout'.
                pub timeout: String,
            }

            /// SecretRef holds the name to a secret that contains a key with the kubeconfig file as the value. If no key is specified the key will default to 'value'. The secret must be in the same namespace as the HelmRelease. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Key in the Secret, when not specified an implementation-specific default key is used.
                pub key: String,
                /// Name of the Secret.
                pub name: String,
            }

            /// The name and namespace of the v1beta2.Source the chart is available at.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// APIVersion of the referent.
                pub api_version: String,
                /// Kind of the referent.
                pub kind: String,
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent.
                pub namespace: String,
            }

            /// HelmReleaseSpec defines the desired state of a Helm release.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Chart defines the template of the v1beta2.HelmChart that should be created for this HelmRelease.
                pub chart: Chart,
                /// DependsOn may contain a meta.NamespacedObjectReference slice with references to HelmRelease resources that must be ready before this HelmRelease can be reconciled.
                pub depends_on: Vec<DependsOnItem>,
                /// Install holds the configuration for Helm install actions for this HelmRelease.
                pub install: Install,
                /// Interval at which to reconcile the Helm release.
                pub interval: String,
                /// KubeConfig for reconciling the HelmRelease on a remote cluster. When used in combination with HelmReleaseSpec.ServiceAccountName, forces the controller to act on behalf of that Service Account at the target cluster. If the --default-service-account flag is set, its value will be used as a controller level fallback for when HelmReleaseSpec.ServiceAccountName is empty.
                pub kube_config: KubeConfig,
                /// MaxHistory is the number of revisions saved by Helm for this HelmRelease. Use '0' for an unlimited number of revisions; defaults to '10'.
                pub max_history: i64,
                /// PostRenderers holds an array of Helm PostRenderers, which will be applied in order of their definition.
                pub post_renderers: Vec<PostRenderersItem>,
                /// ReleaseName used for the Helm release. Defaults to a composition of '[TargetNamespace-]Name'.
                pub release_name: String,
                /// Rollback holds the configuration for Helm rollback actions for this HelmRelease.
                pub rollback: Rollback,
                /// The name of the Kubernetes service account to impersonate when reconciling this HelmRelease.
                pub service_account_name: String,
                /// StorageNamespace used for the Helm storage. Defaults to the namespace of the HelmRelease.
                pub storage_namespace: String,
                /// Suspend tells the controller to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false.
                pub suspend: bool,
                /// TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease.
                pub target_namespace: String,
                /// Test holds the configuration for Helm test actions for this HelmRelease.
                pub test: Test,
                /// Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to '5m0s'.
                pub timeout: String,
                /// Uninstall holds the configuration for Helm uninstall actions for this HelmRelease.
                pub uninstall: Uninstall,
                /// Upgrade holds the configuration for Helm upgrade actions for this HelmRelease.
                pub upgrade: Upgrade,
                /// Values holds the values for this Helm release.
                pub values: serde_json::Map<String, serde_json::Value>,
                /// ValuesFrom holds references to resources containing Helm values for this HelmRelease, and information about how they should be merged.
                pub values_from: Vec<ValuesFromItem>,
            }

            /// Spec holds the template for the v1beta2.HelmChartSpec for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ChartSpec {
                /// The name or path the Helm chart is available at in the SourceRef.
                pub chart: String,
                /// Interval at which to check the v1beta2.Source for updates. Defaults to 'HelmReleaseSpec.Interval'.
                pub interval: String,
                /// Determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
                pub reconcile_strategy: String,
                /// The name and namespace of the v1beta2.Source the chart is available at.
                pub source_ref: SourceRef,
                /// Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file defined here is merged before the ValuesFiles items. Ignored when omitted.
                pub values_file: String,
                /// Alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
                pub values_files: Vec<String>,
                /// Version semver expression, ignored for charts from v1beta2.GitRepository and v1beta2.Bucket sources. Defaults to latest when omitted.
                pub version: String,
            }

            /// HelmReleaseStatus defines the observed state of a HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Conditions holds the conditions for the HelmRelease.
                pub conditions: Vec<ConditionsItem>,
                /// Failures is the reconciliation failure count against the latest desired state. It is reset after a successful reconciliation.
                pub failures: i64,
                /// HelmChart is the namespaced name of the HelmChart resource created by the controller for the HelmRelease.
                pub helm_chart: String,
                /// InstallFailures is the install failure count against the latest desired state. It is reset after a successful reconciliation.
                pub install_failures: i64,
                /// LastAppliedRevision is the revision of the last successfully applied source.
                pub last_applied_revision: String,
                /// LastAttemptedRevision is the revision of the last reconciliation attempt.
                pub last_attempted_revision: String,
                /// LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last reconciliation attempt.
                pub last_attempted_values_checksum: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastReleaseRevision is the revision of the last successful Helm release.
                pub last_release_revision: i64,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// UpgradeFailures is the upgrade failure count against the latest desired state. It is reset after a successful reconciliation.
                pub upgrade_failures: i64,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902ItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }

            /// Test holds the configuration for Helm test actions for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Test {
                /// Enable enables Helm test actions for this HelmRelease after an Helm install or upgrade action has been performed.
                pub enable: bool,
                /// IgnoreFailures tells the controller to skip remediation when the Helm tests are run but fail. Can be overwritten for tests run after install or upgrade actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'.
                pub ignore_failures: bool,
                /// Timeout is the time to wait for any individual Kubernetes operation during the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'.
                pub timeout: String,
            }

            /// Uninstall holds the configuration for Helm uninstall actions for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Uninstall {
                /// DisableHooks prevents hooks from running during the Helm rollback action.
                pub disable_hooks: bool,
                /// DisableWait disables waiting for all the resources to be deleted after a Helm uninstall is performed.
                pub disable_wait: bool,
                /// KeepHistory tells Helm to remove all associated resources and mark the release as deleted, but retain the release history.
                pub keep_history: bool,
                /// Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm uninstall action. Defaults to 'HelmReleaseSpec.Timeout'.
                pub timeout: String,
            }

            /// Upgrade holds the configuration for Helm upgrade actions for this HelmRelease.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Upgrade {
                /// CleanupOnFail allows deletion of new resources created during the Helm upgrade action when it fails.
                pub cleanup_on_fail: bool,
                /// CRDs upgrade CRDs from the Helm Chart's crds directory according to the CRD upgrade policy provided here. Valid values are `Skip`, `Create` or `CreateReplace`. Default is `Skip` and if omitted CRDs are neither installed nor upgraded.
                ///  Skip: do neither install nor replace (update) any CRDs.
                ///  Create: new CRDs are created, existing CRDs are neither updated nor deleted.
                ///  CreateReplace: new CRDs are created, existing CRDs are updated (replaced) but not deleted.
                ///  By default, CRDs are not applied during Helm upgrade action. With this option users can opt-in to CRD upgrade, which is not (yet) natively supported by Helm. https://helm.sh/docs/chart_best_practices/custom_resource_definitions.
                pub crds: String,
                /// DisableHooks prevents hooks from running during the Helm upgrade action.
                pub disable_hooks: bool,
                /// DisableOpenAPIValidation prevents the Helm upgrade action from validating rendered templates against the Kubernetes OpenAPI Schema.
                pub disable_open_a_p_i_validation: bool,
                /// DisableWait disables the waiting for resources to be ready after a Helm upgrade has been performed.
                pub disable_wait: bool,
                /// DisableWaitForJobs disables waiting for jobs to complete after a Helm upgrade has been performed.
                pub disable_wait_for_jobs: bool,
                /// Force forces resource updates through a replacement strategy.
                pub force: bool,
                /// PreserveValues will make Helm reuse the last release's values and merge in overrides from 'Values'. Setting this flag makes the HelmRelease non-declarative.
                pub preserve_values: bool,
                /// Remediation holds the remediation configuration for when the Helm upgrade action for the HelmRelease fails. The default is to not perform any action.
                pub remediation: UpgradeRemediation,
                /// Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm upgrade action. Defaults to 'HelmReleaseSpec.Timeout'.
                pub timeout: String,
            }

            /// ValuesReference contains a reference to a resource containing Helm values, and optionally the key they can be found at.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ValuesFromItem {
                /// Kind of the values referent, valid values are ('Secret', 'ConfigMap').
                pub kind: String,
                /// Name of the values referent. Should reside in the same namespace as the referring resource.
                pub name: String,
                /// Optional marks this ValuesReference as optional. When set, a not found error for the values reference is ignored, but any ValuesKey, TargetPath or transient error will still result in a reconciliation failure.
                pub optional: bool,
                /// TargetPath is the YAML dot notation path the value should be merged at. When set, the ValuesKey is expected to be a single flat value. Defaults to 'None', which results in the values getting merged at the root.
                pub target_path: String,
                /// ValuesKey is the data key where the values.yaml or a specific value can be found at. Defaults to 'values.yaml'.
                pub values_key: String,
            }
        }
    }
}
pub mod image_toolkit_fluxcd_io {
    pub mod v1alpha1 {
        pub mod image_policy {
            /// ImagePolicy is the Schema for the imagepolicies API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImagePolicy {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImagePolicy {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImagePolicy";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImagePolicy {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImagePolicy {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImagePolicy", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Alphabetical set of rules to use for alphabetical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Alphabetical {
                /// Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
                pub order: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct FilterTags {
                /// Extract allows a capture group to be extracted from the specified regular expression pattern, useful before tag evaluation.
                pub extract: String,
                /// Pattern specifies a regular expression pattern used to filter for image tags.
                pub pattern: String,
            }

            /// ImageRepositoryRef points at the object specifying the image being scanned
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImageRepositoryRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Numerical set of rules to use for numerical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Numerical {
                /// Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
                pub order: String,
            }

            /// Policy gives the particulars of the policy to be followed in selecting the most recent image
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Policy {
                /// Alphabetical set of rules to use for alphabetical ordering of the tags.
                pub alphabetical: Alphabetical,
                /// Numerical set of rules to use for numerical ordering of the tags.
                pub numerical: Numerical,
                /// SemVer gives a semantic version range to check against the tags available.
                pub semver: Semver,
            }

            /// SemVer gives a semantic version range to check against the tags available.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Semver {
                /// Range gives a semver range for the image tag; the highest version within the range that's a tag yields the latest image.
                pub range: String,
            }

            /// ImagePolicySpec defines the parameters for calculating the ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
                pub filter_tags: FilterTags,
                /// ImageRepositoryRef points at the object specifying the image being scanned
                pub image_repository_ref: ImageRepositoryRef,
                /// Policy gives the particulars of the policy to be followed in selecting the most recent image
                pub policy: Policy,
            }

            /// ImagePolicyStatus defines the observed state of ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LatestImage gives the first in the list of images scanned by the image repository, when filtered and ordered according to the policy.
                pub latest_image: String,
                pub observed_generation: i64,
            }
        }
        pub mod image_repository {
            /// ImageRepository is the Schema for the imagerepositories API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageRepository";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// CertSecretRef can be given the name of a secret containing either or both of
            ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
            ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CertSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// LastScanResult contains the number of fetched tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct LastScanResult {
                pub scan_time: String,
                pub tag_count: i64,
            }

            /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// CertSecretRef can be given the name of a secret containing either or both of
                ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
                ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
                pub cert_secret_ref: CertSecretRef,
                /// Image is the name of the image repository
                pub image: String,
                /// Interval is the length of time to wait between scans of the image repository.
                pub interval: String,
                /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend subsequent image scans. It does not apply to already started scans. Defaults to false.
                pub suspend: bool,
                /// Timeout for image scanning. Defaults to 'Interval' duration.
                pub timeout: String,
            }

            /// ImageRepositoryStatus defines the observed state of ImageRepository
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// CanonicalName is the name of the image repository with all the implied bits made explicit; e.g., `docker.io/library/alpine` rather than `alpine`.
                pub canonical_image_name: String,
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastScanResult contains the number of fetched tags.
                pub last_scan_result: LastScanResult,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
            }
        }
        pub mod image_update_automation {
            /// ImageUpdateAutomation is the Schema for the imageupdateautomations API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageUpdateAutomation {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageUpdateAutomation {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageUpdateAutomation";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageUpdateAutomation {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageUpdateAutomation {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageUpdateAutomation", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Checkout gives the parameters for cloning the git repository, ready to make changes.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Checkout {
                /// Branch gives the branch to clone from the git repository. If `.spec.push` is not supplied, commits will also be pushed to this branch.
                pub branch: String,
                /// GitRepositoryRef refers to the resource giving access details to a git repository to update files in.
                pub git_repository_ref: GitRepositoryRef,
            }

            /// Commit specifies how to commit to the git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Commit {
                /// AuthorEmail gives the email to provide when making a commit
                pub author_email: String,
                /// AuthorName gives the name to provide when making a commit
                pub author_name: String,
                /// MessageTemplate provides a template for the commit message, into which will be interpolated the details of the change made.
                pub message_template: String,
                /// SigningKey provides the option to sign commits with a GPG key
                pub signing_key: SigningKey,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// GitRepositoryRef refers to the resource giving access details to a git repository to update files in.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct GitRepositoryRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch`.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Push {
                /// Branch specifies that commits should be pushed to the branch named. The branch is created using `.spec.checkout.branch` as the starting point, if it doesn't already exist.
                pub branch: String,
            }

            /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SigningKey provides the option to sign commits with a GPG key
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SigningKey {
                /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
                pub secret_ref: SecretRef,
            }

            /// ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Checkout gives the parameters for cloning the git repository, ready to make changes.
                pub checkout: Checkout,
                /// Commit specifies how to commit to the git repository.
                pub commit: Commit,
                /// Interval gives an lower bound for how often the automation run should be attempted.
                pub interval: String,
                /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch`.
                pub push: Push,
                /// Suspend tells the controller to not run this automation, until it is unset (or set to false). Defaults to false.
                pub suspend: bool,
                /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
                pub update: Update,
            }

            /// ImageUpdateAutomationStatus defines the observed state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LastAutomationRunTime records the last time the controller ran this automation through to completion (even if no updates were made).
                pub last_automation_run_time: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastPushCommit records the SHA1 of the last commit made by the controller, for this automation object
                pub last_push_commit: String,
                /// LastPushTime records the time of the last pushed change.
                pub last_push_time: String,
                pub observed_generation: i64,
            }

            /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Update {
                /// Path to the directory containing the manifests to be updated. Defaults to 'None', which translates to the root path of the GitRepositoryRef.
                pub path: String,
                /// Strategy names the strategy to be used.
                pub strategy: String,
            }
        }
    }
    pub mod v1alpha2 {
        pub mod image_policy {
            /// ImagePolicy is the Schema for the imagepolicies API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImagePolicy {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImagePolicy {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha2";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImagePolicy";
                const VERSION: &'static str = "v1alpha2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImagePolicy {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImagePolicy {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImagePolicy", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Alphabetical set of rules to use for alphabetical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Alphabetical {
                /// Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
                pub order: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct FilterTags {
                /// Extract allows a capture group to be extracted from the specified regular expression pattern, useful before tag evaluation.
                pub extract: String,
                /// Pattern specifies a regular expression pattern used to filter for image tags.
                pub pattern: String,
            }

            /// ImageRepositoryRef points at the object specifying the image being scanned
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImageRepositoryRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Numerical set of rules to use for numerical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Numerical {
                /// Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
                pub order: String,
            }

            /// Policy gives the particulars of the policy to be followed in selecting the most recent image
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Policy {
                /// Alphabetical set of rules to use for alphabetical ordering of the tags.
                pub alphabetical: Alphabetical,
                /// Numerical set of rules to use for numerical ordering of the tags.
                pub numerical: Numerical,
                /// SemVer gives a semantic version range to check against the tags available.
                pub semver: Semver,
            }

            /// SemVer gives a semantic version range to check against the tags available.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Semver {
                /// Range gives a semver range for the image tag; the highest version within the range that's a tag yields the latest image.
                pub range: String,
            }

            /// ImagePolicySpec defines the parameters for calculating the ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
                pub filter_tags: FilterTags,
                /// ImageRepositoryRef points at the object specifying the image being scanned
                pub image_repository_ref: ImageRepositoryRef,
                /// Policy gives the particulars of the policy to be followed in selecting the most recent image
                pub policy: Policy,
            }

            /// ImagePolicyStatus defines the observed state of ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LatestImage gives the first in the list of images scanned by the image repository, when filtered and ordered according to the policy.
                pub latest_image: String,
                pub observed_generation: i64,
            }
        }
        pub mod image_repository {
            /// ImageRepository is the Schema for the imagerepositories API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha2";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageRepository";
                const VERSION: &'static str = "v1alpha2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// CertSecretRef can be given the name of a secret containing either or both of
            ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
            ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CertSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// LastScanResult contains the number of fetched tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct LastScanResult {
                pub scan_time: String,
                pub tag_count: i64,
            }

            /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// CertSecretRef can be given the name of a secret containing either or both of
                ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
                ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
                pub cert_secret_ref: CertSecretRef,
                /// Image is the name of the image repository
                pub image: String,
                /// Interval is the length of time to wait between scans of the image repository.
                pub interval: String,
                /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend subsequent image scans. It does not apply to already started scans. Defaults to false.
                pub suspend: bool,
                /// Timeout for image scanning. Defaults to 'Interval' duration.
                pub timeout: String,
            }

            /// ImageRepositoryStatus defines the observed state of ImageRepository
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// CanonicalName is the name of the image repository with all the implied bits made explicit; e.g., `docker.io/library/alpine` rather than `alpine`.
                pub canonical_image_name: String,
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastScanResult contains the number of fetched tags.
                pub last_scan_result: LastScanResult,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
            }
        }
        pub mod image_update_automation {
            /// ImageUpdateAutomation is the Schema for the imageupdateautomations API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageUpdateAutomation {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageUpdateAutomation {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1alpha2";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageUpdateAutomation";
                const VERSION: &'static str = "v1alpha2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageUpdateAutomation {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageUpdateAutomation {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageUpdateAutomation", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Author gives the email and optionally the name to use as the author of commits.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Author {
                /// Email gives the email to provide when making a commit.
                pub email: String,
                /// Name gives the name to provide when making a commit.
                pub name: String,
            }

            /// Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Checkout {
                /// Reference gives a branch, tag or commit to clone from the Git repository.
                pub r#ref: Ref,
            }

            /// Commit specifies how to commit to the git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Commit {
                /// Author gives the email and optionally the name to use as the author of commits.
                pub author: Author,
                /// MessageTemplate provides a template for the commit message, into which will be interpolated the details of the change made.
                pub message_template: String,
                /// SigningKey provides the option to sign commits with a GPG key
                pub signing_key: SigningKey,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Git {
                /// Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
                pub checkout: Checkout,
                /// Commit specifies how to commit to the git repository.
                pub commit: Commit,
                /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
                pub push: Push,
            }

            /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Push {
                /// Branch specifies that commits should be pushed to the branch named. The branch is created using `.spec.checkout.branch` as the starting point, if it doesn't already exist.
                pub branch: String,
            }

            /// Reference gives a branch, tag or commit to clone from the Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Ref {
                /// The Git branch to checkout, defaults to master.
                pub branch: String,
                /// The Git commit SHA to checkout, if specified Tag filters will be ignored.
                pub commit: String,
                /// The Git tag semver expression, takes precedence over Tag.
                pub semver: String,
                /// The Git tag to checkout, takes precedence over Branch.
                pub tag: String,
            }

            /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SigningKey provides the option to sign commits with a GPG key
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SigningKey {
                /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
                pub secret_ref: SecretRef,
            }

            /// SourceRef refers to the resource giving access details to a git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// API version of the referent
                pub api_version: String,
                /// Kind of the referent
                pub kind: String,
                /// Name of the referent
                pub name: String,
            }

            /// ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
                pub git: Git,
                /// Interval gives an lower bound for how often the automation run should be attempted.
                pub interval: String,
                /// SourceRef refers to the resource giving access details to a git repository.
                pub source_ref: SourceRef,
                /// Suspend tells the controller to not run this automation, until it is unset (or set to false). Defaults to false.
                pub suspend: bool,
                /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
                pub update: Update,
            }

            /// ImageUpdateAutomationStatus defines the observed state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LastAutomationRunTime records the last time the controller ran this automation through to completion (even if no updates were made).
                pub last_automation_run_time: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastPushCommit records the SHA1 of the last commit made by the controller, for this automation object
                pub last_push_commit: String,
                /// LastPushTime records the time of the last pushed change.
                pub last_push_time: String,
                pub observed_generation: i64,
            }

            /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Update {
                /// Path to the directory containing the manifests to be updated. Defaults to 'None', which translates to the root path of the GitRepositoryRef.
                pub path: String,
                /// Strategy names the strategy to be used.
                pub strategy: String,
            }
        }
    }
    pub mod v1beta1 {
        pub mod image_policy {
            /// ImagePolicy is the Schema for the imagepolicies API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImagePolicy {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImagePolicy {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImagePolicy";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImagePolicy {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImagePolicy {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImagePolicy", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Alphabetical set of rules to use for alphabetical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Alphabetical {
                /// Order specifies the sorting order of the tags. Given the letters of the alphabet as tags, ascending order would select Z, and descending order would select A.
                pub order: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct FilterTags {
                /// Extract allows a capture group to be extracted from the specified regular expression pattern, useful before tag evaluation.
                pub extract: String,
                /// Pattern specifies a regular expression pattern used to filter for image tags.
                pub pattern: String,
            }

            /// ImageRepositoryRef points at the object specifying the image being scanned
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImageRepositoryRef {
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// Numerical set of rules to use for numerical ordering of the tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Numerical {
                /// Order specifies the sorting order of the tags. Given the integer values from 0 to 9 as tags, ascending order would select 9, and descending order would select 0.
                pub order: String,
            }

            /// Policy gives the particulars of the policy to be followed in selecting the most recent image
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Policy {
                /// Alphabetical set of rules to use for alphabetical ordering of the tags.
                pub alphabetical: Alphabetical,
                /// Numerical set of rules to use for numerical ordering of the tags.
                pub numerical: Numerical,
                /// SemVer gives a semantic version range to check against the tags available.
                pub semver: Semver,
            }

            /// SemVer gives a semantic version range to check against the tags available.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Semver {
                /// Range gives a semver range for the image tag; the highest version within the range that's a tag yields the latest image.
                pub range: String,
            }

            /// ImagePolicySpec defines the parameters for calculating the ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// FilterTags enables filtering for only a subset of tags based on a set of rules. If no rules are provided, all the tags from the repository will be ordered and compared.
                pub filter_tags: FilterTags,
                /// ImageRepositoryRef points at the object specifying the image being scanned
                pub image_repository_ref: ImageRepositoryRef,
                /// Policy gives the particulars of the policy to be followed in selecting the most recent image
                pub policy: Policy,
            }

            /// ImagePolicyStatus defines the observed state of ImagePolicy
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LatestImage gives the first in the list of images scanned by the image repository, when filtered and ordered according to the policy.
                pub latest_image: String,
                pub observed_generation: i64,
            }
        }
        pub mod image_repository {
            /// ImageRepository is the Schema for the imagerepositories API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageRepository";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// CertSecretRef can be given the name of a secret containing either or both of
            ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
            ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CertSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// LastScanResult contains the number of fetched tags.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct LastScanResult {
                pub scan_time: String,
                pub tag_count: i64,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// ImageRepositorySpec defines the parameters for scanning an image repository, e.g., `fluxcd/flux`.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom defines an ACL for allowing cross-namespace references to the ImageRepository object based on the caller's namespace labels.
                pub access_from: AccessFrom,
                /// CertSecretRef can be given the name of a secret containing either or both of
                ///   - a PEM-encoded client certificate (`certFile`) and private  key (`keyFile`);  - a PEM-encoded CA certificate (`caFile`)
                ///   and whichever are supplied, will be used for connecting to the  registry. The client cert and key are useful if you are  authenticating with a certificate; the CA cert is useful if  you are using a self-signed server certificate.
                pub cert_secret_ref: CertSecretRef,
                /// ExclusionList is a list of regex strings used to exclude certain tags from being stored in the database.
                pub exclusion_list: Vec<String>,
                /// Image is the name of the image repository
                pub image: String,
                /// Interval is the length of time to wait between scans of the image repository.
                pub interval: String,
                /// SecretRef can be given the name of a secret containing credentials to use for the image registry. The secret should be created with `kubectl create secret docker-registry`, or the equivalent.
                pub secret_ref: SecretRef,
                /// ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate the image pull if the service account has attached pull secrets.
                pub service_account_name: String,
                /// This flag tells the controller to suspend subsequent image scans. It does not apply to already started scans. Defaults to false.
                pub suspend: bool,
                /// Timeout for image scanning. Defaults to 'Interval' duration.
                pub timeout: String,
            }

            /// ImageRepositoryStatus defines the observed state of ImageRepository
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// CanonicalName is the name of the image repository with all the implied bits made explicit; e.g., `docker.io/library/alpine` rather than `alpine`.
                pub canonical_image_name: String,
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastScanResult contains the number of fetched tags.
                pub last_scan_result: LastScanResult,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
            }
        }
        pub mod image_update_automation {
            /// ImageUpdateAutomation is the Schema for the imageupdateautomations API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct ImageUpdateAutomation {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ImageUpdateAutomation {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "image.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "image.toolkit.fluxcd.io";
                const KIND: &'static str = "ImageUpdateAutomation";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ImageUpdateAutomation {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ImageUpdateAutomation {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ImageUpdateAutomation", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Author gives the email and optionally the name to use as the author of commits.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Author {
                /// Email gives the email to provide when making a commit.
                pub email: String,
                /// Name gives the name to provide when making a commit.
                pub name: String,
            }

            /// Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Checkout {
                /// Reference gives a branch, tag or commit to clone from the Git repository.
                pub r#ref: Ref,
            }

            /// Commit specifies how to commit to the git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Commit {
                /// Author gives the email and optionally the name to use as the author of commits.
                pub author: Author,
                /// MessageTemplate provides a template for the commit message, into which will be interpolated the details of the change made.
                pub message_template: String,
                /// SigningKey provides the option to sign commits with a GPG key
                pub signing_key: SigningKey,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Git {
                /// Checkout gives the parameters for cloning the git repository, ready to make changes. If not present, the `spec.ref` field from the referenced `GitRepository` or its default will be used.
                pub checkout: Checkout,
                /// Commit specifies how to commit to the git repository.
                pub commit: Commit,
                /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
                pub push: Push,
            }

            /// Push specifies how and where to push commits made by the automation. If missing, commits are pushed (back) to `.spec.checkout.branch` or its default.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Push {
                /// Branch specifies that commits should be pushed to the branch named. The branch is created using `.spec.checkout.branch` as the starting point, if it doesn't already exist.
                pub branch: String,
            }

            /// Reference gives a branch, tag or commit to clone from the Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Ref {
                /// Branch to check out, defaults to 'master' if no other field is defined.
                ///  When GitRepositorySpec.GitImplementation is set to 'go-git', a shallow clone of the specified branch is performed.
                pub branch: String,
                /// Commit SHA to check out, takes precedence over all reference fields.
                ///  When GitRepositorySpec.GitImplementation is set to 'go-git', this can be combined with Branch to shallow clone the branch, in which the commit is expected to exist.
                pub commit: String,
                /// SemVer tag expression to check out, takes precedence over Tag.
                pub semver: String,
                /// Tag to check out, takes precedence over Branch.
                pub tag: String,
            }

            /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SigningKey provides the option to sign commits with a GPG key
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SigningKey {
                /// SecretRef holds the name to a secret that contains a 'git.asc' key corresponding to the ASCII Armored file containing the GPG signing keypair as the value. It must be in the same namespace as the ImageUpdateAutomation.
                pub secret_ref: SecretRef,
            }

            /// SourceRef refers to the resource giving access details to a git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// API version of the referent.
                pub api_version: String,
                /// Kind of the referent.
                pub kind: String,
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
                pub namespace: String,
            }

            /// ImageUpdateAutomationSpec defines the desired state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// GitSpec contains all the git-specific definitions. This is technically optional, but in practice mandatory until there are other kinds of source allowed.
                pub git: Git,
                /// Interval gives an lower bound for how often the automation run should be attempted.
                pub interval: String,
                /// SourceRef refers to the resource giving access details to a git repository.
                pub source_ref: SourceRef,
                /// Suspend tells the controller to not run this automation, until it is unset (or set to false). Defaults to false.
                pub suspend: bool,
                /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
                pub update: Update,
            }

            /// ImageUpdateAutomationStatus defines the observed state of ImageUpdateAutomation
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// LastAutomationRunTime records the last time the controller ran this automation through to completion (even if no updates were made).
                pub last_automation_run_time: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// LastPushCommit records the SHA1 of the last commit made by the controller, for this automation object
                pub last_push_commit: String,
                /// LastPushTime records the time of the last pushed change.
                pub last_push_time: String,
                pub observed_generation: i64,
            }

            /// Update gives the specification for how to update the files in the repository. This can be left empty, to use the default value.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Update {
                /// Path to the directory containing the manifests to be updated. Defaults to 'None', which translates to the root path of the GitRepositoryRef.
                pub path: String,
                /// Strategy names the strategy to be used.
                pub strategy: String,
            }
        }
    }
}
pub mod kustomize_toolkit_fluxcd_io {
    pub mod v1beta1 {
        pub mod kustomization {
            /// Kustomization is the Schema for the kustomizations API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Kustomization {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Kustomization {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "kustomize.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "kustomize.toolkit.fluxcd.io";
                const KIND: &'static str = "Kustomization";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Kustomization {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Kustomization {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Kustomization", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// Decrypt Kubernetes secrets before applying them on the cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Decryption {
                /// Provider is the name of the decryption engine.
                pub provider: String,
                /// The secret name containing the private OpenPGP keys used for decryption.
                pub secret_ref: DecryptionSecretRef,
            }

            /// NamespacedObjectReference contains enough information to locate the referenced Kubernetes resource object in any namespace.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DependsOnItem {
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// Snapshot holds the metadata of namespaced Kubernetes objects
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct EntriesItem {
                /// The list of Kubernetes kinds.
                pub kinds: Kinds,
                /// The namespace of this entry.
                pub namespace: String,
            }

            /// NamespacedObjectKindReference contains enough information to locate the typed referenced Kubernetes resource object in any namespace.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct HealthChecksItem {
                /// API version of the referent, if not specified the Kubernetes preferred version will be used.
                pub api_version: String,
                /// Kind of the referent.
                pub kind: String,
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// Image contains an image name, a new name, a new tag or digest, which will replace the original name and tag.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImagesItem {
                /// Digest is the value used to replace the original image tag. If digest is present NewTag value is ignored.
                pub digest: String,
                /// Name is a tag-less image name.
                pub name: String,
                /// NewName is the value used to replace the original name.
                pub new_name: String,
                /// NewTag is the value used to replace the original tag.
                pub new_tag: String,
            }

            /// The list of Kubernetes kinds.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Kinds {
                /// The list of Kubernetes kinds.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The KubeConfig for reconciling the Kustomization on a remote cluster. When specified, KubeConfig takes precedence over ServiceAccountName.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubeConfig {
                /// SecretRef holds the name to a secret that contains a 'value' key with the kubeconfig file as the value. It must be in the same namespace as the Kustomization. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the Kustomization.
                pub secret_ref: KubeConfigSecretRef,
            }

            /// JSON6902 is a JSON6902 operation object. https://datatracker.ietf.org/doc/html/rfc6902#section-4
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchItem {
                /// From contains a JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub from: String,
                /// Op indicates the operation to perform. Its value MUST be one of "add", "remove", "replace", "move", "copy", or "test". https://datatracker.ietf.org/doc/html/rfc6902#section-4
                pub op: String,
                /// Path contains the JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op.
                pub path: String,
                /// Value contains a valid JSON structure. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub value: serde_json::Map<String, serde_json::Value>,
            }

            /// Patch contains an inline StrategicMerge or JSON6902 patch, and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItem {
                /// Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with an array of operation objects.
                pub patch: String,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesItemTarget,
            }

            /// JSON6902Patch contains a JSON6902 patch and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902Item {
                /// Patch contains the JSON6902 patch document with an array of operation objects.
                pub patch: Vec<PatchItem>,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesJson6902ItemTarget,
            }

            /// PostBuild describes which actions to perform on the YAML manifest generated by building the kustomize overlay.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PostBuild {
                /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
                pub substitute: Substitute,
                /// SubstituteFrom holds references to ConfigMaps and Secrets containing the variables and their values to be substituted in the YAML manifests. The ConfigMap and the Secret data keys represent the var names and they must match the vars declared in the manifests for the substitution to happen.
                pub substitute_from: Vec<SubstituteFromItem>,
            }

            /// The secret name containing the private OpenPGP keys used for decryption.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DecryptionSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SecretRef holds the name to a secret that contains a 'value' key with the kubeconfig file as the value. It must be in the same namespace as the Kustomization. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the Kustomization.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubeConfigSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// The last successfully applied revision metadata.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Snapshot {
                /// The manifests sha1 checksum.
                pub checksum: String,
                /// A list of Kubernetes kinds grouped by namespace.
                pub entries: Vec<EntriesItem>,
            }

            /// Reference of the source where the kustomization file is.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// API version of the referent
                pub api_version: String,
                /// Kind of the referent
                pub kind: String,
                /// Name of the referent
                pub name: String,
                /// Namespace of the referent, defaults to the Kustomization namespace
                pub namespace: String,
            }

            /// KustomizationSpec defines the desired state of a kustomization.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Decrypt Kubernetes secrets before applying them on the cluster.
                pub decryption: Decryption,
                /// DependsOn may contain a meta.NamespacedObjectReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled.
                pub depends_on: Vec<DependsOnItem>,
                /// Force instructs the controller to recreate resources when patching fails due to an immutable field change.
                pub force: bool,
                /// A list of resources to be included in the health assessment.
                pub health_checks: Vec<HealthChecksItem>,
                /// Images is a list of (image name, new name, new tag or digest) for changing image names, tags or digests. This can also be achieved with a patch, but this operator is simpler to specify.
                pub images: Vec<ImagesItem>,
                /// The interval at which to reconcile the Kustomization.
                pub interval: String,
                /// The KubeConfig for reconciling the Kustomization on a remote cluster. When specified, KubeConfig takes precedence over ServiceAccountName.
                pub kube_config: KubeConfig,
                /// Strategic merge and JSON patches, defined as inline YAML objects, capable of targeting objects based on kind, label and annotation selectors.
                pub patches: Vec<PatchesItem>,
                /// JSON 6902 patches, defined as inline YAML objects.
                pub patches_json6902: Vec<PatchesJson6902Item>,
                /// Strategic merge patches, defined as inline YAML objects.
                pub patches_strategic_merge: Vec<serde_json::Map<String, serde_json::Value>>,
                /// Path to the directory containing the kustomization.yaml file, or the set of plain YAMLs a kustomization.yaml should be generated for. Defaults to 'None', which translates to the root path of the SourceRef.
                pub path: String,
                /// PostBuild describes which actions to perform on the YAML manifest generated by building the kustomize overlay.
                pub post_build: PostBuild,
                /// Prune enables garbage collection.
                pub prune: bool,
                /// The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the KustomizationSpec.Interval value to retry failures.
                pub retry_interval: String,
                /// The name of the Kubernetes service account to impersonate when reconciling this Kustomization.
                pub service_account_name: String,
                /// Reference of the source where the kustomization file is.
                pub source_ref: SourceRef,
                /// This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false.
                pub suspend: bool,
                /// TargetNamespace sets or overrides the namespace in the kustomization.yaml file.
                pub target_namespace: String,
                /// Timeout for validation, apply and health checking operations. Defaults to 'Interval' duration.
                pub timeout: String,
                /// Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be 'client' (local dry-run), 'server' (APIServer dry-run) or 'none'. When 'Force' is 'true', validation will fallback to 'client' if set to 'server' because server-side validation is not supported in this scenario.
                pub validation: String,
            }

            /// KustomizationStatus defines the observed state of a kustomization.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// The last successfully applied revision. The revision format for Git sources is <branch|tag>/<commit-sha>.
                pub last_applied_revision: String,
                /// LastAttemptedRevision is the revision of the last reconciliation attempt.
                pub last_attempted_revision: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
                /// The last successfully applied revision metadata.
                pub snapshot: Snapshot,
            }

            /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Substitute {
                /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// SubstituteReference contains a reference to a resource containing the variables name and value.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SubstituteFromItem {
                /// Kind of the values referent, valid values are ('Secret', 'ConfigMap').
                pub kind: String,
                /// Name of the values referent. Should reside in the same namespace as the referring resource.
                pub name: String,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902ItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }
        }
    }
    pub mod v1beta2 {
        pub mod kustomization {
            /// Kustomization is the Schema for the kustomizations API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Kustomization {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Kustomization {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "kustomize.toolkit.fluxcd.io/v1beta2";
                const GROUP: &'static str = "kustomize.toolkit.fluxcd.io";
                const KIND: &'static str = "Kustomization";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Kustomization {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Kustomization {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Kustomization", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// Decrypt Kubernetes secrets before applying them on the cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Decryption {
                /// Provider is the name of the decryption engine.
                pub provider: String,
                /// The secret name containing the private OpenPGP keys used for decryption.
                pub secret_ref: DecryptionSecretRef,
            }

            /// NamespacedObjectReference contains enough information to locate the referenced Kubernetes resource object in any namespace.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DependsOnItem {
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// ResourceRef contains the information necessary to locate a resource within a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct EntriesItem {
                /// ID is the string representation of the Kubernetes resource object's metadata, in the format '<namespace>_<name>_<group>_<kind>'.
                pub id: String,
                /// Version is the API version of the Kubernetes resource object's kind.
                pub v: String,
            }

            /// NamespacedObjectKindReference contains enough information to locate the typed referenced Kubernetes resource object in any namespace.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct HealthChecksItem {
                /// API version of the referent, if not specified the Kubernetes preferred version will be used.
                pub api_version: String,
                /// Kind of the referent.
                pub kind: String,
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, when not specified it acts as LocalObjectReference.
                pub namespace: String,
            }

            /// Image contains an image name, a new name, a new tag or digest, which will replace the original name and tag.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ImagesItem {
                /// Digest is the value used to replace the original image tag. If digest is present NewTag value is ignored.
                pub digest: String,
                /// Name is a tag-less image name.
                pub name: String,
                /// NewName is the value used to replace the original name.
                pub new_name: String,
                /// NewTag is the value used to replace the original tag.
                pub new_tag: String,
            }

            /// Inventory contains the list of Kubernetes resource object references that have been successfully applied.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Inventory {
                /// Entries of Kubernetes resource object references.
                pub entries: Vec<EntriesItem>,
            }

            /// The KubeConfig for reconciling the Kustomization on a remote cluster. When used in combination with KustomizationSpec.ServiceAccountName, forces the controller to act on behalf of that Service Account at the target cluster. If the --default-service-account flag is set, its value will be used as a controller level fallback for when KustomizationSpec.ServiceAccountName is empty.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubeConfig {
                /// SecretRef holds the name of a secret that contains a key with the kubeconfig file as the value. If no key is set, the key will default to 'value'. The secret must be in the same namespace as the Kustomization. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the Kustomization.
                pub secret_ref: KubeConfigSecretRef,
            }

            /// JSON6902 is a JSON6902 operation object. https://datatracker.ietf.org/doc/html/rfc6902#section-4
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchItem {
                /// From contains a JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub from: String,
                /// Op indicates the operation to perform. Its value MUST be one of "add", "remove", "replace", "move", "copy", or "test". https://datatracker.ietf.org/doc/html/rfc6902#section-4
                pub op: String,
                /// Path contains the JSON-pointer value that references a location within the target document where the operation is performed. The meaning of the value depends on the value of Op.
                pub path: String,
                /// Value contains a valid JSON structure. The meaning of the value depends on the value of Op, and is NOT taken into account by all operations.
                pub value: serde_json::Map<String, serde_json::Value>,
            }

            /// Patch contains an inline StrategicMerge or JSON6902 patch, and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItem {
                /// Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with an array of operation objects.
                pub patch: String,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesItemTarget,
            }

            /// JSON6902Patch contains a JSON6902 patch and the target the patch should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902Item {
                /// Patch contains the JSON6902 patch document with an array of operation objects.
                pub patch: Vec<PatchItem>,
                /// Target points to the resources that the patch document should be applied to.
                pub target: PatchesJson6902ItemTarget,
            }

            /// PostBuild describes which actions to perform on the YAML manifest generated by building the kustomize overlay.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PostBuild {
                /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
                pub substitute: Substitute,
                /// SubstituteFrom holds references to ConfigMaps and Secrets containing the variables and their values to be substituted in the YAML manifests. The ConfigMap and the Secret data keys represent the var names and they must match the vars declared in the manifests for the substitution to happen.
                pub substitute_from: Vec<SubstituteFromItem>,
            }

            /// The secret name containing the private OpenPGP keys used for decryption.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DecryptionSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SecretRef holds the name of a secret that contains a key with the kubeconfig file as the value. If no key is set, the key will default to 'value'. The secret must be in the same namespace as the Kustomization. It is recommended that the kubeconfig is self-contained, and the secret is regularly updated if credentials such as a cloud-access-token expire. Cloud specific `cmd-path` auth helpers will not function without adding binaries and credentials to the Pod that is responsible for reconciling the Kustomization.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubeConfigSecretRef {
                /// Key in the Secret, when not specified an implementation-specific default key is used.
                pub key: String,
                /// Name of the Secret.
                pub name: String,
            }

            /// Reference of the source where the kustomization file is.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// API version of the referent.
                pub api_version: String,
                /// Kind of the referent.
                pub kind: String,
                /// Name of the referent.
                pub name: String,
                /// Namespace of the referent, defaults to the namespace of the Kubernetes resource object that contains the reference.
                pub namespace: String,
            }

            /// KustomizationSpec defines the configuration to calculate the desired state from a Source using Kustomize.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Decrypt Kubernetes secrets before applying them on the cluster.
                pub decryption: Decryption,
                /// DependsOn may contain a meta.NamespacedObjectReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled.
                pub depends_on: Vec<DependsOnItem>,
                /// Force instructs the controller to recreate resources when patching fails due to an immutable field change.
                pub force: bool,
                /// A list of resources to be included in the health assessment.
                pub health_checks: Vec<HealthChecksItem>,
                /// Images is a list of (image name, new name, new tag or digest) for changing image names, tags or digests. This can also be achieved with a patch, but this operator is simpler to specify.
                pub images: Vec<ImagesItem>,
                /// The interval at which to reconcile the Kustomization.
                pub interval: String,
                /// The KubeConfig for reconciling the Kustomization on a remote cluster. When used in combination with KustomizationSpec.ServiceAccountName, forces the controller to act on behalf of that Service Account at the target cluster. If the --default-service-account flag is set, its value will be used as a controller level fallback for when KustomizationSpec.ServiceAccountName is empty.
                pub kube_config: KubeConfig,
                /// Strategic merge and JSON patches, defined as inline YAML objects, capable of targeting objects based on kind, label and annotation selectors.
                pub patches: Vec<PatchesItem>,
                /// JSON 6902 patches, defined as inline YAML objects. Deprecated: Use Patches instead.
                pub patches_json6902: Vec<PatchesJson6902Item>,
                /// Strategic merge patches, defined as inline YAML objects. Deprecated: Use Patches instead.
                pub patches_strategic_merge: Vec<serde_json::Map<String, serde_json::Value>>,
                /// Path to the directory containing the kustomization.yaml file, or the set of plain YAMLs a kustomization.yaml should be generated for. Defaults to 'None', which translates to the root path of the SourceRef.
                pub path: String,
                /// PostBuild describes which actions to perform on the YAML manifest generated by building the kustomize overlay.
                pub post_build: PostBuild,
                /// Prune enables garbage collection.
                pub prune: bool,
                /// The interval at which to retry a previously failed reconciliation. When not specified, the controller uses the KustomizationSpec.Interval value to retry failures.
                pub retry_interval: String,
                /// The name of the Kubernetes service account to impersonate when reconciling this Kustomization.
                pub service_account_name: String,
                /// Reference of the source where the kustomization file is.
                pub source_ref: SourceRef,
                /// This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false.
                pub suspend: bool,
                /// TargetNamespace sets or overrides the namespace in the kustomization.yaml file.
                pub target_namespace: String,
                /// Timeout for validation, apply and health checking operations. Defaults to 'Interval' duration.
                pub timeout: String,
                /// Deprecated: Not used in v1beta2.
                pub validation: String,
                /// Wait instructs the controller to check the health of all the reconciled resources. When enabled, the HealthChecks are ignored. Defaults to false.
                pub wait: bool,
            }

            /// KustomizationStatus defines the observed state of a kustomization.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// Inventory contains the list of Kubernetes resource object references that have been successfully applied.
                pub inventory: Inventory,
                /// The last successfully applied revision. The revision format for Git sources is <branch|tag>/<commit-sha>.
                pub last_applied_revision: String,
                /// LastAttemptedRevision is the revision of the last reconciliation attempt.
                pub last_attempted_revision: String,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
            }

            /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Substitute {
                /// Substitute holds a map of key/value pairs. The variables defined in your YAML manifests that match any of the keys defined in the map will be substituted with the set value. Includes support for bash string replacement functions e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// SubstituteReference contains a reference to a resource containing the variables name and value.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SubstituteFromItem {
                /// Kind of the values referent, valid values are ('Secret', 'ConfigMap').
                pub kind: String,
                /// Name of the values referent. Should reside in the same namespace as the referring resource.
                pub name: String,
                /// Optional indicates whether the referenced resource must exist, or whether to tolerate its absence. If true and the referenced resource is absent, proceed as if the resource was present but empty, without any variables defined.
                pub optional: bool,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }

            /// Target points to the resources that the patch document should be applied to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PatchesJson6902ItemTarget {
                /// AnnotationSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource annotations.
                pub annotation_selector: String,
                /// Group is the API group to select resources from. Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub group: String,
                /// Kind of the API Group to select resources from. Together with Group and Version it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub kind: String,
                /// LabelSelector is a string that follows the label selection expression https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api It matches with the resource labels.
                pub label_selector: String,
                /// Name to match resources with.
                pub name: String,
                /// Namespace to select resources from.
                pub namespace: String,
                /// Version of the API Group to select resources from. Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources. https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md
                pub version: String,
            }
        }
    }
}
pub mod notification_toolkit_fluxcd_io {
    pub mod v1beta1 {
        pub mod alert {
            /// Alert is the Schema for the alerts API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Alert {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Alert {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "notification.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "notification.toolkit.fluxcd.io";
                const KIND: &'static str = "Alert";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Alert {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Alert {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Alert", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct EventSourcesItem {
                /// API version of the referent
                pub api_version: String,
                /// Kind of the referent
                pub kind: String,
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
                /// Name of the referent
                pub name: String,
                /// Namespace of the referent
                pub namespace: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Send events using this provider.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ProviderRef {
                /// Name of the referent.
                pub name: String,
            }

            /// AlertSpec defines an alerting rule for events involving a list of objects
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Filter events based on severity, defaults to ('info'). If set to 'info' no events will be filtered.
                pub event_severity: String,
                /// Filter events based on the involved objects.
                pub event_sources: Vec<EventSourcesItem>,
                /// A list of Golang regular expressions to be used for excluding messages.
                pub exclusion_list: Vec<String>,
                /// Send events using this provider.
                pub provider_ref: ProviderRef,
                /// Short description of the impact and affected cluster.
                pub summary: String,
                /// This flag tells the controller to suspend subsequent events dispatching. Defaults to false.
                pub suspend: bool,
            }

            /// AlertStatus defines the observed state of Alert
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
            }
        }
        pub mod provider {
            /// Provider is the Schema for the providers API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Provider {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Provider {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "notification.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "notification.toolkit.fluxcd.io";
                const KIND: &'static str = "Provider";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Provider {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Provider {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Provider", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// CertSecretRef can be given the name of a secret containing a PEM-encoded CA certificate (`caFile`)
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CertSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// Secret reference containing the provider webhook URL using "address" as data key
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// ProviderSpec defines the desired state of Provider
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// HTTP/S webhook address of this provider
                pub address: String,
                /// CertSecretRef can be given the name of a secret containing a PEM-encoded CA certificate (`caFile`)
                pub cert_secret_ref: CertSecretRef,
                /// Alert channel for this provider
                pub channel: String,
                /// HTTP/S address of the proxy
                pub proxy: String,
                /// Secret reference containing the provider webhook URL using "address" as data key
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend subsequent events handling. Defaults to false.
                pub suspend: bool,
                /// Type of provider
                pub r#type: String,
                /// Bot username for this provider
                pub username: String,
            }

            /// ProviderStatus defines the observed state of Provider
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// ObservedGeneration is the last reconciled generation.
                pub observed_generation: i64,
            }
        }
        pub mod receiver {
            /// Receiver is the Schema for the receivers API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Receiver {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Receiver {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "notification.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "notification.toolkit.fluxcd.io";
                const KIND: &'static str = "Receiver";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Receiver {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Receiver {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Receiver", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ResourcesItem {
                /// API version of the referent
                pub api_version: String,
                /// Kind of the referent
                pub kind: String,
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
                /// Name of the referent
                pub name: String,
                /// Namespace of the referent
                pub namespace: String,
            }

            /// Secret reference containing the token used to validate the payload authenticity
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// ReceiverSpec defines the desired state of Receiver
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// A list of events to handle, e.g. 'push' for GitHub or 'Push Hook' for GitLab.
                pub events: Vec<String>,
                /// A list of resources to be notified about changes.
                pub resources: Vec<ResourcesItem>,
                /// Secret reference containing the token used to validate the payload authenticity
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend subsequent events handling. Defaults to false.
                pub suspend: bool,
                /// Type of webhook sender, used to determine the validation procedure and payload deserialization.
                pub r#type: String,
            }

            /// ReceiverStatus defines the observed state of Receiver
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Vec<ConditionsItem>,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// Generated webhook URL in the format of '/hook/sha256sum(token+name+namespace)'.
                pub url: String,
            }
        }
    }
}
pub mod source_toolkit_fluxcd_io {
    pub mod v1beta1 {
        pub mod bucket {
            /// Bucket is the Schema for the buckets API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Bucket {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Bucket {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "Bucket";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Bucket {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Bucket {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Bucket", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the output of the last successful Bucket sync.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the artifact.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of this artifact.
                pub last_update_time: String,
                /// Path is the relative file path of this artifact.
                pub path: String,
                /// Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc.
                pub revision: String,
                /// URL is the HTTP address of this artifact.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// The name of the secret containing authentication credentials for the Bucket.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// BucketSpec defines the desired state of an S3 compatible bucket
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
                pub access_from: AccessFrom,
                /// The bucket name.
                pub bucket_name: String,
                /// The bucket endpoint address.
                pub endpoint: String,
                /// Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
                pub ignore: String,
                /// Insecure allows connecting to a non-TLS S3 HTTP endpoint.
                pub insecure: bool,
                /// The interval at which to check for bucket updates.
                pub interval: String,
                /// The S3 compatible storage provider name, default ('generic').
                pub provider: String,
                /// The bucket region.
                pub region: String,
                /// The name of the secret containing authentication credentials for the Bucket.
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend the reconciliation of this source.
                pub suspend: bool,
                /// The timeout for download operations, defaults to 60s.
                pub timeout: String,
            }

            /// BucketStatus defines the observed state of a bucket
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the output of the last successful Bucket sync.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the Bucket.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// URL is the download link for the artifact output of the last Bucket sync.
                pub url: String,
            }
        }
        pub mod git_repository {
            /// GitRepository is the Schema for the gitrepositories API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct GitRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for GitRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "GitRepository";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for GitRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for GitRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("GitRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the output of the last successful repository sync.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the artifact.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of this artifact.
                pub last_update_time: String,
                /// Path is the relative file path of this artifact.
                pub path: String,
                /// Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc.
                pub revision: String,
                /// URL is the HTTP address of this artifact.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// GitRepositoryInclude defines a source with a from and to path.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct IncludeItem {
                /// The path to copy contents from, defaults to the root directory.
                pub from_path: String,
                /// Reference to a GitRepository to include.
                pub repository: Repository,
                /// The path to copy contents to, defaults to the name of the source ref.
                pub to_path: String,
            }

            /// Artifact represents the output of a source synchronisation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct IncludedArtifactsItem {
                /// Checksum is the SHA256 checksum of the artifact.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of this artifact.
                pub last_update_time: String,
                /// Path is the relative file path of this artifact.
                pub path: String,
                /// Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc.
                pub revision: String,
                /// URL is the HTTP address of this artifact.
                pub url: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// The Git reference to checkout and monitor for changes, defaults to master branch.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Ref {
                /// The Git branch to checkout, defaults to master.
                pub branch: String,
                /// The Git commit SHA to checkout, if specified Tag filters will be ignored.
                pub commit: String,
                /// The Git tag semver expression, takes precedence over Tag.
                pub semver: String,
                /// The Git tag to checkout, takes precedence over Branch.
                pub tag: String,
            }

            /// Reference to a GitRepository to include.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Repository {
                /// Name of the referent.
                pub name: String,
            }

            /// The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity and known_hosts fields.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// The secret name containing the public keys of all trusted Git authors.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct VerifySecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// GitRepositorySpec defines the desired state of a Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
                pub access_from: AccessFrom,
                /// Determines which git client library to use. Defaults to go-git, valid values are ('go-git', 'libgit2').
                pub git_implementation: String,
                /// Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
                pub ignore: String,
                /// Extra git repositories to map into the repository
                pub include: Vec<IncludeItem>,
                /// The interval at which to check for repository updates.
                pub interval: String,
                /// When enabled, after the clone is created, initializes all submodules within, using their default settings. This option is available only when using the 'go-git' GitImplementation.
                pub recurse_submodules: bool,
                /// The Git reference to checkout and monitor for changes, defaults to master branch.
                pub r#ref: Ref,
                /// The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity and known_hosts fields.
                pub secret_ref: SpecSecretRef,
                /// This flag tells the controller to suspend the reconciliation of this source.
                pub suspend: bool,
                /// The timeout for remote Git operations like cloning, defaults to 60s.
                pub timeout: String,
                /// The repository URL, can be a HTTP/S or SSH address.
                pub url: String,
                /// Verify OpenPGP signature for the Git commit HEAD points to.
                pub verify: Verify,
            }

            /// GitRepositoryStatus defines the observed state of a Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the output of the last successful repository sync.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the GitRepository.
                pub conditions: Vec<ConditionsItem>,
                /// IncludedArtifacts represents the included artifacts from the last successful repository sync.
                pub included_artifacts: Vec<IncludedArtifactsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// URL is the download link for the artifact output of the last repository sync.
                pub url: String,
            }

            /// Verify OpenPGP signature for the Git commit HEAD points to.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Verify {
                /// Mode describes what git object should be verified, currently ('head').
                pub mode: String,
                /// The secret name containing the public keys of all trusted Git authors.
                pub secret_ref: VerifySecretRef,
            }
        }
        pub mod helm_chart {
            /// HelmChart is the Schema for the helmcharts API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct HelmChart {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for HelmChart {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "HelmChart";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for HelmChart {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for HelmChart {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("HelmChart", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the output of the last successful chart sync.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the artifact.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of this artifact.
                pub last_update_time: String,
                /// Path is the relative file path of this artifact.
                pub path: String,
                /// Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc.
                pub revision: String,
                /// URL is the HTTP address of this artifact.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// The reference to the Source the chart is available at.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// APIVersion of the referent.
                pub api_version: String,
                /// Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
                pub kind: String,
                /// Name of the referent.
                pub name: String,
            }

            /// HelmChartSpec defines the desired state of a Helm chart.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
                pub access_from: AccessFrom,
                /// The name or path the Helm chart is available at in the SourceRef.
                pub chart: String,
                /// The interval at which to check the Source for updates.
                pub interval: String,
                /// Determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
                pub reconcile_strategy: String,
                /// The reference to the Source the chart is available at.
                pub source_ref: SourceRef,
                /// This flag tells the controller to suspend the reconciliation of this source.
                pub suspend: bool,
                /// Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file defined here is merged before the ValuesFiles items. Ignored when omitted.
                pub values_file: String,
                /// Alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
                pub values_files: Vec<String>,
                /// The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted.
                pub version: String,
            }

            /// HelmChartStatus defines the observed state of the HelmChart.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the output of the last successful chart sync.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the HelmChart.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// URL is the download link for the last chart pulled.
                pub url: String,
            }
        }
        pub mod helm_repository {
            /// HelmRepository is the Schema for the helmrepositories API
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct HelmRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for HelmRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta1";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "HelmRepository";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for HelmRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for HelmRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("HelmRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the output of the last successful repository sync.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the artifact.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of this artifact.
                pub last_update_time: String,
                /// Path is the relative file path of this artifact.
                pub path: String,
                /// Revision is a human readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm index timestamp, a Helm chart version, etc.
                pub revision: String,
                /// URL is the HTTP address of this artifact.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// HelmRepositorySpec defines the reference to a Helm repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom defines an Access Control List for allowing cross-namespace references to this object.
                pub access_from: AccessFrom,
                /// The interval at which to check the upstream for updates.
                pub interval: String,
                /// PassCredentials allows the credentials from the SecretRef to be passed on to a host that does not match the host as defined in URL. This may be required if the host of the advertised chart URLs in the index differ from the defined URL. Enabling this should be done with caution, as it can potentially result in credentials getting stolen in a MITM-attack.
                pub pass_credentials: bool,
                /// The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain a certFile and keyFile, and/or caCert fields.
                pub secret_ref: SecretRef,
                /// This flag tells the controller to suspend the reconciliation of this source.
                pub suspend: bool,
                /// The timeout of index downloading, defaults to 60s.
                pub timeout: String,
                /// The Helm repository URL, a valid URL contains at least a protocol and host.
                pub url: String,
            }

            /// HelmRepositoryStatus defines the observed state of the HelmRepository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the output of the last successful repository sync.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the HelmRepository.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation.
                pub observed_generation: i64,
                /// URL is the download link for the last index fetched.
                pub url: String,
            }
        }
    }
    pub mod v1beta2 {
        pub mod bucket {
            /// Bucket is the Schema for the buckets API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct Bucket {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Bucket {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta2";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "Bucket";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Bucket {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Bucket {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Bucket", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the last successful Bucket reconciliation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the Artifact file.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
                pub last_update_time: String,
                /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of the Artifact storage on the local file system of the controller managing the Source.
                pub path: String,
                /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
                pub revision: String,
                /// Size is the number of bytes in the file.
                pub size: i64,
                /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact contents.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// SecretRef specifies the Secret containing authentication credentials for the Bucket.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// BucketSpec specifies the required configuration to produce an Artifact for an object storage bucket.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
                pub access_from: AccessFrom,
                /// BucketName is the name of the object storage bucket.
                pub bucket_name: String,
                /// Endpoint is the object storage address the BucketName is located at.
                pub endpoint: String,
                /// Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
                pub ignore: String,
                /// Insecure allows connecting to a non-TLS HTTP Endpoint.
                pub insecure: bool,
                /// Interval at which to check the Endpoint for updates.
                pub interval: String,
                /// Provider of the object storage bucket. Defaults to 'generic', which expects an S3 (API) compatible object storage.
                pub provider: String,
                /// Region of the Endpoint where the BucketName is located in.
                pub region: String,
                /// SecretRef specifies the Secret containing authentication credentials for the Bucket.
                pub secret_ref: SecretRef,
                /// Suspend tells the controller to suspend the reconciliation of this Bucket.
                pub suspend: bool,
                /// Timeout for fetch operations, defaults to 60s.
                pub timeout: String,
            }

            /// BucketStatus records the observed state of a Bucket.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the last successful Bucket reconciliation.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the Bucket.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation of the Bucket object.
                pub observed_generation: i64,
                /// URL is the dynamic fetch link for the latest Artifact. It is provided on a "best effort" basis, and using the precise BucketStatus.Artifact data is recommended.
                pub url: String,
            }
        }
        pub mod git_repository {
            /// GitRepository is the Schema for the gitrepositories API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct GitRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for GitRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta2";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "GitRepository";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for GitRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for GitRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("GitRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the last successful GitRepository reconciliation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the Artifact file.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
                pub last_update_time: String,
                /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of the Artifact storage on the local file system of the controller managing the Source.
                pub path: String,
                /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
                pub revision: String,
                /// Size is the number of bytes in the file.
                pub size: i64,
                /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact contents.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// GitRepositoryInclude specifies a local reference to a GitRepository which Artifact (sub-)contents must be included, and where they should be placed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct IncludeItem {
                /// FromPath specifies the path to copy contents from, defaults to the root of the Artifact.
                pub from_path: String,
                /// GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
                pub repository: Repository,
                /// ToPath specifies the path to copy contents to, defaults to the name of the GitRepositoryRef.
                pub to_path: String,
            }

            /// Artifact represents the output of a Source reconciliation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct IncludedArtifactsItem {
                /// Checksum is the SHA256 checksum of the Artifact file.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
                pub last_update_time: String,
                /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of the Artifact storage on the local file system of the controller managing the Source.
                pub path: String,
                /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
                pub revision: String,
                /// Size is the number of bytes in the file.
                pub size: i64,
                /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact contents.
                pub url: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Ref {
                /// Branch to check out, defaults to 'master' if no other field is defined.
                ///  When GitRepositorySpec.GitImplementation is set to 'go-git', a shallow clone of the specified branch is performed.
                pub branch: String,
                /// Commit SHA to check out, takes precedence over all reference fields.
                ///  When GitRepositorySpec.GitImplementation is set to 'go-git', this can be combined with Branch to shallow clone the branch, in which the commit is expected to exist.
                pub commit: String,
                /// SemVer tag expression to check out, takes precedence over Tag.
                pub semver: String,
                /// Tag to check out, takes precedence over Branch.
                pub tag: String,
            }

            /// GitRepositoryRef specifies the GitRepository which Artifact contents must be included.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Repository {
                /// Name of the referent.
                pub name: String,
            }

            /// SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecSecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// SecretRef specifies the Secret containing the public keys of trusted Git authors.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct VerifySecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// GitRepositorySpec specifies the required configuration to produce an Artifact for a Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
                pub access_from: AccessFrom,
                /// GitImplementation specifies which Git client library implementation to use. Defaults to 'go-git', valid values are ('go-git', 'libgit2').
                pub git_implementation: String,
                /// Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are.
                pub ignore: String,
                /// Include specifies a list of GitRepository resources which Artifacts should be included in the Artifact produced for this GitRepository.
                pub include: Vec<IncludeItem>,
                /// Interval at which to check the GitRepository for updates.
                pub interval: String,
                /// RecurseSubmodules enables the initialization of all submodules within the GitRepository as cloned from the URL, using their default settings. This option is available only when using the 'go-git' GitImplementation.
                pub recurse_submodules: bool,
                /// Reference specifies the Git reference to resolve and monitor for changes, defaults to the 'master' branch.
                pub r#ref: Ref,
                /// SecretRef specifies the Secret containing authentication credentials for the GitRepository. For HTTPS repositories the Secret must contain 'username' and 'password' fields. For SSH repositories the Secret must contain 'identity' and 'known_hosts' fields.
                pub secret_ref: SpecSecretRef,
                /// Suspend tells the controller to suspend the reconciliation of this GitRepository.
                pub suspend: bool,
                /// Timeout for Git operations like cloning, defaults to 60s.
                pub timeout: String,
                /// URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
                pub url: String,
                /// Verification specifies the configuration to verify the Git commit signature(s).
                pub verify: Verify,
            }

            /// GitRepositoryStatus records the observed state of a Git repository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the last successful GitRepository reconciliation.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the GitRepository.
                pub conditions: Vec<ConditionsItem>,
                /// ContentConfigChecksum is a checksum of all the configurations related to the content of the source artifact:  - .spec.ignore  - .spec.recurseSubmodules  - .spec.included and the checksum of the included artifacts observed in .status.observedGeneration version of the object. This can be used to determine if the content of the included repository has changed. It has the format of `<algo>:<checksum>`, for example: `sha256:<checksum>`.
                pub content_config_checksum: String,
                /// IncludedArtifacts contains a list of the last successfully included Artifacts as instructed by GitRepositorySpec.Include.
                pub included_artifacts: Vec<IncludedArtifactsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation of the GitRepository object.
                pub observed_generation: i64,
                /// URL is the dynamic fetch link for the latest Artifact. It is provided on a "best effort" basis, and using the precise GitRepositoryStatus.Artifact data is recommended.
                pub url: String,
            }

            /// Verification specifies the configuration to verify the Git commit signature(s).
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Verify {
                /// Mode specifies what Git object should be verified, currently ('head').
                pub mode: String,
                /// SecretRef specifies the Secret containing the public keys of trusted Git authors.
                pub secret_ref: VerifySecretRef,
            }
        }
        pub mod helm_chart {
            /// HelmChart is the Schema for the helmcharts API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct HelmChart {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for HelmChart {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta2";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "HelmChart";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for HelmChart {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for HelmChart {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("HelmChart", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the output of the last successful reconciliation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the Artifact file.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
                pub last_update_time: String,
                /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of the Artifact storage on the local file system of the controller managing the Source.
                pub path: String,
                /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
                pub revision: String,
                /// Size is the number of bytes in the file.
                pub size: i64,
                /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact contents.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// SourceRef is the reference to the Source the chart is available at.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceRef {
                /// APIVersion of the referent.
                pub api_version: String,
                /// Kind of the referent, valid values are ('HelmRepository', 'GitRepository', 'Bucket').
                pub kind: String,
                /// Name of the referent.
                pub name: String,
            }

            /// HelmChartSpec specifies the desired state of a Helm chart.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
                pub access_from: AccessFrom,
                /// Chart is the name or path the Helm chart is available at in the SourceRef.
                pub chart: String,
                /// Interval is the interval at which to check the Source for updates.
                pub interval: String,
                /// ReconcileStrategy determines what enables the creation of a new artifact. Valid values are ('ChartVersion', 'Revision'). See the documentation of the values for an explanation on their behavior. Defaults to ChartVersion when omitted.
                pub reconcile_strategy: String,
                /// SourceRef is the reference to the Source the chart is available at.
                pub source_ref: SourceRef,
                /// Suspend tells the controller to suspend the reconciliation of this source.
                pub suspend: bool,
                /// ValuesFile is an alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Deprecated in favor of ValuesFiles, for backwards compatibility the file specified here is merged before the ValuesFiles items. Ignored when omitted.
                pub values_file: String,
                /// ValuesFiles is an alternative list of values files to use as the chart values (values.yaml is not included by default), expected to be a relative path in the SourceRef. Values files are merged in the order of this list with the last file overriding the first. Ignored when omitted.
                pub values_files: Vec<String>,
                /// Version is the chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted.
                pub version: String,
            }

            /// HelmChartStatus records the observed state of the HelmChart.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the output of the last successful reconciliation.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the HelmChart.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedChartName is the last observed chart name as specified by the resolved chart reference.
                pub observed_chart_name: String,
                /// ObservedGeneration is the last observed generation of the HelmChart object.
                pub observed_generation: i64,
                /// ObservedSourceArtifactRevision is the last observed Artifact.Revision of the HelmChartSpec.SourceRef.
                pub observed_source_artifact_revision: String,
                /// URL is the dynamic fetch link for the latest Artifact. It is provided on a "best effort" basis, and using the precise BucketStatus.Artifact data is recommended.
                pub url: String,
            }
        }
        pub mod helm_repository {
            /// HelmRepository is the Schema for the helmrepositories API.
            #[derive(serde::Deserialize, Debug, PartialEq)]
            pub struct HelmRepository {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for HelmRepository {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "source.toolkit.fluxcd.io/v1beta2";
                const GROUP: &'static str = "source.toolkit.fluxcd.io";
                const KIND: &'static str = "HelmRepository";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for HelmRepository {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for HelmRepository {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("HelmRepository", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessFrom {
                /// NamespaceSelectors is the list of namespace selectors to which this ACL applies. Items in this list are evaluated using a logical OR operation.
                pub namespace_selectors: Vec<NamespaceSelectorsItem>,
            }

            /// Artifact represents the last successful HelmRepository reconciliation.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Artifact {
                /// Checksum is the SHA256 checksum of the Artifact file.
                pub checksum: String,
                /// LastUpdateTime is the timestamp corresponding to the last update of the Artifact.
                pub last_update_time: String,
                /// Path is the relative file path of the Artifact. It can be used to locate the file in the root of the Artifact storage on the local file system of the controller managing the Source.
                pub path: String,
                /// Revision is a human-readable identifier traceable in the origin source system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
                pub revision: String,
                /// Size is the number of bytes in the file.
                pub size: i64,
                /// URL is the HTTP address of the Artifact as exposed by the controller managing the Source. It can be used to retrieve the Artifact for consumption, e.g. by another controller applying the Artifact contents.
                pub url: String,
            }

            /// Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"`
            ///      // other fields }
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                pub last_transition_time: String,
                /// message is a human readable message indicating details about the transition. This may be an empty string.
                pub message: String,
                /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
                pub observed_generation: i64,
                /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
                pub reason: String,
                /// status of the condition, one of True, False, Unknown.
                pub status: String,
                /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
                pub r#type: String,
            }

            /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// NamespaceSelector selects the namespaces to which this ACL applies. An empty map of MatchLabels matches all namespaces in a cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NamespaceSelectorsItem {
                /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                pub match_labels: MatchLabels,
            }

            /// SecretRef specifies the Secret containing authentication credentials for the HelmRepository. For HTTP/S basic auth the secret must contain 'username' and 'password' fields. For TLS the secret must contain a 'certFile' and 'keyFile', and/or 'caCert' fields.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SecretRef {
                /// Name of the referent.
                pub name: String,
            }

            /// HelmRepositorySpec specifies the required configuration to produce an Artifact for a Helm repository index YAML.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// AccessFrom specifies an Access Control List for allowing cross-namespace references to this object. NOTE: Not implemented, provisional as of https://github.com/fluxcd/flux2/pull/2092
                pub access_from: AccessFrom,
                /// Interval at which to check the URL for updates.
                pub interval: String,
                /// PassCredentials allows the credentials from the SecretRef to be passed on to a host that does not match the host as defined in URL. This may be required if the host of the advertised chart URLs in the index differ from the defined URL. Enabling this should be done with caution, as it can potentially result in credentials getting stolen in a MITM-attack.
                pub pass_credentials: bool,
                /// SecretRef specifies the Secret containing authentication credentials for the HelmRepository. For HTTP/S basic auth the secret must contain 'username' and 'password' fields. For TLS the secret must contain a 'certFile' and 'keyFile', and/or 'caCert' fields.
                pub secret_ref: SecretRef,
                /// Suspend tells the controller to suspend the reconciliation of this HelmRepository.
                pub suspend: bool,
                /// Timeout of the index fetch operation, defaults to 60s.
                pub timeout: String,
                /// Type of the HelmRepository. When this field is set to  "oci", the URL field value must be prefixed with "oci://".
                pub r#type: String,
                /// URL of the Helm repository, a valid URL contains at least a protocol and host.
                pub url: String,
            }

            /// HelmRepositoryStatus records the observed state of the HelmRepository.
            #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Artifact represents the last successful HelmRepository reconciliation.
                pub artifact: Artifact,
                /// Conditions holds the conditions for the HelmRepository.
                pub conditions: Vec<ConditionsItem>,
                /// LastHandledReconcileAt holds the value of the most recent reconcile request value, so a change of the annotation value can be detected.
                pub last_handled_reconcile_at: String,
                /// ObservedGeneration is the last observed generation of the HelmRepository object.
                pub observed_generation: i64,
                /// URL is the dynamic fetch link for the latest Artifact. It is provided on a "best effort" basis, and using the precise HelmRepositoryStatus.Artifact data is recommended.
                pub url: String,
            }
        }
    }
}
