// Generated by:
// target/debug/k8s-crds-codegen

pub mod extensions_istio_io {
    pub mod v1alpha1 {
        pub mod wasm_plugin {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WasmPlugin {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EnvItem {
                pub name: String,
                /// Value for the environment variable.
                pub value: String,
                pub value_from: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The configuration that will be passed on to the plugin.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct PluginConfig {
                /// The configuration that will be passed on to the plugin.
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// Extend the functionality provided by the Istio proxy through WebAssembly filters. See more details at: https://istio.io/docs/reference/config/proxy_extensions/wasm-plugin.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub image_pull_policy: String,
                /// Credentials to use for OCI image pulling.
                pub image_pull_secret: String,
                /// Determines where in the filter chain this `WasmPlugin` is to be injected.
                pub phase: String,
                /// The configuration that will be passed on to the plugin.
                pub plugin_config: PluginConfig,
                pub plugin_name: String,
                /// Determines ordering of `WasmPlugins` in the same `phase`.
                pub priority: Option<i64>,
                pub selector: Selector,
                /// SHA256 checksum that will be used to verify Wasm module or OCI container.
                pub sha256: String,
                /// URL of a Wasm module or OCI container.
                pub url: String,
                pub verification_key: String,
                /// Configuration for a Wasm VM.
                pub vm_config: VmConfig,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Configuration for a Wasm VM.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct VmConfig {
                /// Specifies environment variables to be injected to this VM.
                pub env: Vec<EnvItem>,
            }

            impl k8s_openapi::Resource for WasmPlugin {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "extensions.istio.io/v1alpha1";
                const GROUP: &'static str = "extensions.istio.io";
                const KIND: &'static str = "WasmPlugin";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for WasmPlugin {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
}
pub mod install_istio_io {
    pub mod v1alpha1 {
        pub mod istio_operator {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct IstioOperator {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
            }

            impl k8s_openapi::Resource for IstioOperator {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "install.istio.io/v1alpha1";
                const GROUP: &'static str = "install.istio.io";
                const KIND: &'static str = "IstioOperator";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for IstioOperator {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
}
pub mod networking_istio_io {
    pub mod v1alpha3 {
        pub mod destination_rule {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct DestinationRule {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPool {
                /// HTTP connection pool settings.
                pub http: SubsetsItemTrafficPolicyConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SubsetsItemTrafficPolicyConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPool {
                /// HTTP connection pool settings.
                pub http: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPool {
                /// HTTP connection pool settings.
                pub http: SpecTrafficPolicyConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SpecTrafficPolicyConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPool {
                /// HTTP connection pool settings.
                pub http: SpecTrafficPolicyPortLevelSettingsItemConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie: SubsetsItemTrafficPolicyLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash {
            /// Hash based on HTTP cookie.
            pub http_cookie: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie,
            /// Hash based on a specific HTTP header.
            pub http_header_name: String,
            /// Hash based on a specific HTTP query parameter.
            pub http_query_parameter_name: String,
            pub minimum_ring_size: i64,
            /// Hash based on the source IP address.
            pub use_source_ip: bool,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie: SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem {
                /// Originating locality, '/' separated, e.g.
                pub from: String,
                /// Map of upstream localities to traffic distribution weights.
                pub to: SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem {
            /// Originating locality, '/' separated, e.g.
            pub from: String,
            /// Map of upstream localities to traffic distribution weights.
            pub to: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem {
                /// Originating locality, '/' separated, e.g.
                pub from: String,
                /// Map of upstream localities to traffic distribution weights.
                pub to: SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem {
            /// Originating locality, '/' separated, e.g.
            pub from: String,
            /// Map of upstream localities to traffic distribution weights.
            pub to: SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancer {
                pub consistent_hash: SubsetsItemTrafficPolicyLoadBalancerConsistentHash,
                pub locality_lb_setting: SubsetsItemTrafficPolicyLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancer {
                pub consistent_hash:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash,
                pub locality_lb_setting:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancer {
                pub consistent_hash: SpecTrafficPolicyLoadBalancerConsistentHash,
                pub locality_lb_setting: SpecTrafficPolicyLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancer {
                pub consistent_hash:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash,
                pub locality_lb_setting:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSetting {
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub distribute:
                    Vec<SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem>,
                /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
                pub enabled: Option<bool>,
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub failover:
                    Vec<SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem>,
                /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
                pub failover_priority: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting {
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub distribute: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem>,
            /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
            pub enabled: Option<bool>,
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub failover: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem>,
            /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
            pub failover_priority: Vec<String>,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSetting {
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub distribute: Vec<SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem>,
                /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
                pub enabled: Option<bool>,
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub failover: Vec<SpecTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem>,
                /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
                pub failover_priority: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting {
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub distribute: Vec<SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem>,
            /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
            pub enabled: Option<bool>,
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub failover: Vec<SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem>,
            /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
            pub failover_priority: Vec<String>,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemPort {
                pub number: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemPort {
                pub number: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItem {
                pub connection_pool: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancer,
                pub outlier_detection:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemOutlierDetection,
                pub port: SubsetsItemTrafficPolicyPortLevelSettingsItemPort,
                /// TLS related settings for connections to the upstream service.
                pub tls: SubsetsItemTrafficPolicyPortLevelSettingsItemTls,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItem {
                pub connection_pool: SpecTrafficPolicyPortLevelSettingsItemConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SpecTrafficPolicyPortLevelSettingsItemLoadBalancer,
                pub outlier_detection: SpecTrafficPolicyPortLevelSettingsItemOutlierDetection,
                pub port: SpecTrafficPolicyPortLevelSettingsItemPort,
                /// TLS related settings for connections to the upstream service.
                pub tls: SpecTrafficPolicyPortLevelSettingsItemTls,
            }

            /// Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// A list of namespaces to which this destination rule is exported.
                pub export_to: Vec<String>,
                /// The name of a service from the service registry.
                pub host: String,
                pub subsets: Vec<SubsetsItem>,
                pub traffic_policy: SpecTrafficPolicy,
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItem {
                pub labels: Labels,
                /// Name of the subset.
                pub name: String,
                /// Traffic policies that apply to this subset.
                pub traffic_policy: SubsetsItemTrafficPolicy,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive: SubsetsItemTrafficPolicyConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive: SpecTrafficPolicyConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive:
                    SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo
            {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Traffic policies that apply to this subset.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicy {
                pub connection_pool: SubsetsItemTrafficPolicyConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SubsetsItemTrafficPolicyLoadBalancer,
                pub outlier_detection: SubsetsItemTrafficPolicyOutlierDetection,
                /// Traffic policies specific to individual ports.
                pub port_level_settings: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItem>,
                /// TLS related settings for connections to the upstream service.
                pub tls: SubsetsItemTrafficPolicyTls,
                pub tunnel: SubsetsItemTrafficPolicyTunnel,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicy {
                pub connection_pool: SpecTrafficPolicyConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SpecTrafficPolicyLoadBalancer,
                pub outlier_detection: SpecTrafficPolicyOutlierDetection,
                /// Traffic policies specific to individual ports.
                pub port_level_settings: Vec<SpecTrafficPolicyPortLevelSettingsItem>,
                /// TLS related settings for connections to the upstream service.
                pub tls: SpecTrafficPolicyTls,
                pub tunnel: SpecTrafficPolicyTunnel,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyTunnel {
                /// Specifies which protocol to use for tunneling the downstream connection.
                pub protocol: String,
                /// Specifies a host to which the downstream connection is tunneled.
                pub target_host: String,
                /// Specifies a port to which the downstream connection is tunneled.
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyTunnel {
                /// Specifies which protocol to use for tunneling the downstream connection.
                pub protocol: String,
                /// Specifies a host to which the downstream connection is tunneled.
                pub target_host: String,
                /// Specifies a port to which the downstream connection is tunneled.
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub match_labels: MatchLabels,
            }

            impl k8s_openapi::Resource for DestinationRule {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "DestinationRule";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for DestinationRule {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod envoy_filter {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EnvoyFilter {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            /// Match on envoy cluster attributes.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Cluster {
                /// The exact name of the cluster to match.
                pub name: String,
                /// The service port for which this cluster was generated.
                pub port_number: i64,
                /// The fully qualified service name for this cluster.
                pub service: String,
                /// The subset associated with the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ConfigPatchesItem {
                pub apply_to: String,
                /// Match on listener/route configuration/cluster.
                pub r#match: Match,
                /// The patch to apply along with the operation.
                pub patch: Patch,
            }

            /// The name of a specific filter to apply the patch to.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Filter {
                /// The filter name to match on.
                pub name: String,
                pub sub_filter: SubFilter,
            }

            /// Match a specific filter chain in a listener.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct FilterChain {
                /// Applies only to sidecars.
                pub application_protocols: String,
                /// The destination_port value used by a filter chain's match condition.
                pub destination_port: i64,
                /// The name of a specific filter to apply the patch to.
                pub filter: Filter,
                /// The name assigned to the filter chain.
                pub name: String,
                /// The SNI value used by a filter chain's match condition.
                pub sni: String,
                /// Applies only to `SIDECAR_INBOUND` context.
                pub transport_protocol: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Match on envoy listener attributes.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Listener {
                /// Match a specific filter chain in a listener.
                pub filter_chain: FilterChain,
                /// Match a specific listener by its name.
                pub name: String,
                pub port_name: String,
                pub port_number: i64,
            }

            /// Match on listener/route configuration/cluster.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Match {
                /// Match on envoy cluster attributes.
                pub cluster: Cluster,
                /// The specific config generation context to match on.
                pub context: String,
                /// Match on envoy listener attributes.
                pub listener: Listener,
                /// Match on properties associated with a proxy.
                pub proxy: Proxy,
                /// Match on envoy HTTP route configuration attributes.
                pub route_configuration: RouteConfiguration,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Metadata {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The patch to apply along with the operation.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Patch {
                /// Determines the filter insertion order.
                pub filter_class: String,
                /// Determines how the patch should be applied.
                pub operation: String,
                /// The JSON config of the object being patched.
                pub value: Value,
            }

            /// Match on properties associated with a proxy.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Proxy {
                pub metadata: Metadata,
                pub proxy_version: String,
            }

            /// Match a specific route within the virtual host.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Route {
                /// Match a route with specific action type.
                pub action: String,
                pub name: String,
            }

            /// Match on envoy HTTP route configuration attributes.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteConfiguration {
                pub gateway: String,
                /// Route configuration name to match on.
                pub name: String,
                /// Applicable only for GATEWAY context.
                pub port_name: String,
                pub port_number: i64,
                pub vhost: Vhost,
            }

            /// Customizing Envoy configuration generated by Istio. See more details at: https://istio.io/docs/reference/config/networking/envoy-filter.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// One or more patches with match conditions.
                pub config_patches: Vec<ConfigPatchesItem>,
                /// Priority defines the order in which patch sets are applied within a context.
                pub priority: i32,
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubFilter {
                /// The filter name to match on.
                pub name: String,
            }

            /// The JSON config of the object being patched.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Value {
                /// The JSON config of the object being patched.
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Vhost {
                pub name: String,
                /// Match a specific route within the virtual host.
                pub route: Route,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub labels: Labels,
            }

            impl k8s_openapi::Resource for EnvoyFilter {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "EnvoyFilter";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for EnvoyFilter {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod gateway {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Gateway {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Port {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ServersItem {
                pub bind: String,
                pub default_endpoint: String,
                /// One or more hosts exposed by this gateway.
                pub hosts: Vec<String>,
                /// An optional name of the server, when set must be unique across all servers.
                pub name: String,
                pub port: Port,
                /// Set of TLS related options that govern the server's behavior.
                pub tls: Tls,
            }

            /// Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub selector: Selector,
                /// A list of server specifications.
                pub servers: Vec<ServersItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of TLS related options that govern the server's behavior.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Tls {
                /// REQUIRED if mode is `MUTUAL`.
                pub ca_certificates: String,
                /// Optional: If specified, only support the specified cipher list.
                pub cipher_suites: Vec<String>,
                pub credential_name: String,
                pub https_redirect: bool,
                /// Optional: Maximum TLS protocol version.
                pub max_protocol_version: String,
                /// Optional: Minimum TLS protocol version.
                pub min_protocol_version: String,
                pub mode: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub private_key: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub server_certificate: String,
                pub subject_alt_names: Vec<String>,
                pub verify_certificate_hash: Vec<String>,
                pub verify_certificate_spki: Vec<String>,
            }

            impl k8s_openapi::Resource for Gateway {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "Gateway";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Gateway {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod service_entry {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ServiceEntry {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EndpointsItem {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: EndpointsItemLabels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EndpointsItemLabels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelectorLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct PortsItem {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The virtual IP addresses associated with the service.
                pub addresses: Vec<String>,
                /// One or more endpoints associated with the service.
                pub endpoints: Vec<EndpointsItem>,
                /// A list of namespaces to which this service is exported.
                pub export_to: Vec<String>,
                /// The hosts associated with the ServiceEntry.
                pub hosts: Vec<String>,
                pub location: String,
                /// The ports associated with the external service.
                pub ports: Vec<PortsItem>,
                /// Service discovery mode for the hosts.
                pub resolution: String,
                pub subject_alt_names: Vec<String>,
                /// Applicable only for MESH_INTERNAL services.
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Applicable only for MESH_INTERNAL services.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub labels: WorkloadSelectorLabels,
            }

            impl k8s_openapi::Resource for ServiceEntry {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "ServiceEntry";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ServiceEntry {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod sidecar {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Sidecar {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressItem {
                pub bind: String,
                pub capture_mode: String,
                pub hosts: Vec<String>,
                /// The port associated with the listener.
                pub port: EgressItemPort,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressProxy {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: EgressProxyPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct IngressItem {
                /// The IP to which the listener should be bound.
                pub bind: String,
                pub capture_mode: String,
                pub default_endpoint: String,
                /// The port associated with the listener.
                pub port: IngressItemPort,
                pub tls: Tls,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Configuration for the outbound traffic policy.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct OutboundTrafficPolicy {
                pub egress_proxy: EgressProxy,
                pub mode: String,
            }

            /// The port associated with the listener.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressItemPort {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// The port associated with the listener.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct IngressItemPort {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressProxyPort {
                pub number: i64,
            }

            /// Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub egress: Vec<EgressItem>,
                pub ingress: Vec<IngressItem>,
                /// Configuration for the outbound traffic policy.
                pub outbound_traffic_policy: OutboundTrafficPolicy,
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Tls {
                /// REQUIRED if mode is `MUTUAL`.
                pub ca_certificates: String,
                /// Optional: If specified, only support the specified cipher list.
                pub cipher_suites: Vec<String>,
                pub credential_name: String,
                pub https_redirect: bool,
                /// Optional: Maximum TLS protocol version.
                pub max_protocol_version: String,
                /// Optional: Minimum TLS protocol version.
                pub min_protocol_version: String,
                pub mode: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub private_key: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub server_certificate: String,
                pub subject_alt_names: Vec<String>,
                pub verify_certificate_hash: Vec<String>,
                pub verify_certificate_spki: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub labels: Labels,
            }

            impl k8s_openapi::Resource for Sidecar {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "Sidecar";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Sidecar {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod virtual_service {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct VirtualService {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Abort {
                /// GRPC status code to use to abort the request.
                pub grpc_status: String,
                pub http2_error: String,
                /// HTTP status code to use to abort the Http request.
                pub http_status: i32,
                /// Percentage of requests to be aborted with the error code provided.
                pub percentage: AbortPercentage,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequestAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponseAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequestAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponseAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AllowOriginsItem {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Authority {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            /// Cross-Origin Resource Sharing policy (CORS).
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct CorsPolicy {
                pub allow_credentials: Option<bool>,
                pub allow_headers: Vec<String>,
                /// List of HTTP methods allowed to access the resource.
                pub allow_methods: Vec<String>,
                /// The list of origins that are allowed to perform CORS requests.
                pub allow_origin: Vec<String>,
                /// String patterns that match allowed origins.
                pub allow_origins: Vec<AllowOriginsItem>,
                pub expose_headers: Vec<String>,
                pub max_age: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Delay {
                pub exponential_delay: String,
                /// Add a fixed delay before forwarding the request.
                pub fixed_delay: String,
                /// Percentage of requests on which the delay will be injected (0-100).
                pub percent: i32,
                /// Percentage of requests on which the delay will be injected.
                pub percentage: DelayPercentage,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Delegate {
                /// Name specifies the name of the delegate VirtualService.
                pub name: String,
                /// Namespace specifies the namespace where the delegate VirtualService resides.
                pub namespace: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: HttpItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: TcpItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: TlsItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            /// Fault injection policy to apply on HTTP traffic at the client side.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Fault {
                pub abort: Abort,
                pub delay: Delay,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeaders {
                pub request: HttpItemHeadersRequest,
                pub response: HttpItemHeadersResponse,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchItemHeaders {
                pub properties: std::collections::HashMap<String, HeadersValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeaders {
                pub request: RouteItemHeadersRequest,
                pub response: RouteItemHeadersResponse,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItem {
                /// Cross-Origin Resource Sharing policy (CORS).
                pub cors_policy: CorsPolicy,
                pub delegate: Delegate,
                /// Fault injection policy to apply on HTTP traffic at the client side.
                pub fault: Fault,
                pub headers: HttpItemHeaders,
                pub r#match: Vec<HttpItemMatchItem>,
                pub mirror: Mirror,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percent: Option<i64>,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percentage: MirrorPercentage,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percent: Option<i64>,
                /// The name assigned to the route for debugging purposes.
                pub name: String,
                /// A HTTP rule can either redirect or forward (default) traffic.
                pub redirect: Redirect,
                /// Retry policy for HTTP requests.
                pub retries: Retries,
                /// Rewrite HTTP URIs and Authority headers.
                pub rewrite: Rewrite,
                /// A HTTP rule can either redirect or forward (default) traffic.
                pub route: Vec<HttpItemRouteItem>,
                /// Timeout for HTTP requests, default is disabled.
                pub timeout: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemMatchItem {
                pub authority: Authority,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                pub headers: MatchItemHeaders,
                /// Flag to specify whether the URI matching should be case-insensitive.
                pub ignore_uri_case: bool,
                pub method: Method,
                /// The name assigned to a match.
                pub name: String,
                /// Specifies the ports on the host that is being addressed.
                pub port: i64,
                /// Query parameters for matching.
                pub query_params: QueryParams,
                pub scheme: Scheme,
                pub source_labels: HttpItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
                pub uri: Uri,
                /// withoutHeader has the same syntax with the header, but has opposite meaning.
                pub without_headers: WithoutHeaders,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemMatchItem {
                /// IPv4 or IPv6 ip addresses of destination with optional subnet.
                pub destination_subnets: Vec<String>,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                /// Specifies the port on the host that is being addressed.
                pub port: i64,
                pub source_labels: TcpItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
                /// IPv4 or IPv6 ip address of source with optional subnet.
                pub source_subnet: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemMatchItem {
                /// IPv4 or IPv6 ip addresses of destination with optional subnet.
                pub destination_subnets: Vec<String>,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                /// Specifies the port on the host that is being addressed.
                pub port: i64,
                /// SNI (server name indicator) to match on.
                pub sni_hosts: Vec<String>,
                pub source_labels: TlsItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Method {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Mirror {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: MirrorPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            /// Percentage of the traffic to be mirrored by the `mirror` field.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MirrorPercentage {
                pub value: f64,
            }

            /// Percentage of requests to be aborted with the error code provided.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AbortPercentage {
                pub value: f64,
            }

            /// Percentage of requests on which the delay will be injected.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct DelayPercentage {
                pub value: f64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MirrorPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Query parameters for matching.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct QueryParams {
                /// Query parameters for matching.
                pub properties: std::collections::HashMap<String, QueryParamsValue>,
            }

            /// A HTTP rule can either redirect or forward (default) traffic.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Redirect {
                pub authority: String,
                pub derive_port: String,
                /// On a redirect, overwrite the port portion of the URL with this value.
                pub port: i64,
                pub redirect_code: i64,
                /// On a redirect, overwrite the scheme portion of the URL with this value.
                pub scheme: String,
                pub uri: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequest {
                pub add: HttpItemHeadersRequestAdd,
                pub remove: Vec<String>,
                pub set: HttpItemHeadersRequestSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequest {
                pub add: RouteItemHeadersRequestAdd,
                pub remove: Vec<String>,
                pub set: RouteItemHeadersRequestSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponse {
                pub add: HttpItemHeadersResponseAdd,
                pub remove: Vec<String>,
                pub set: HttpItemHeadersResponseSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponse {
                pub add: RouteItemHeadersResponseAdd,
                pub remove: Vec<String>,
                pub set: RouteItemHeadersResponseSet,
            }

            /// Retry policy for HTTP requests.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Retries {
                /// Number of retries to be allowed for a given request.
                pub attempts: i32,
                /// Timeout per attempt for a given request, including the initial call and any retries.
                pub per_try_timeout: String,
                /// Specifies the conditions under which retry takes place.
                pub retry_on: String,
                /// Flag to specify whether the retries should retry to other localities.
                pub retry_remote_localities: Option<bool>,
            }

            /// Rewrite HTTP URIs and Authority headers.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Rewrite {
                /// rewrite the Authority/Host header with this value.
                pub authority: String,
                pub uri: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItem {
                pub destination: HttpItemRouteItemDestination,
                pub headers: RouteItemHeaders,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItem {
                pub destination: TcpItemRouteItemDestination,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItem {
                pub destination: TlsItemRouteItemDestination,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Scheme {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequestSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponseSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequestSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponseSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// A list of namespaces to which this virtual service is exported.
                pub export_to: Vec<String>,
                /// The names of gateways and sidecars that should apply these routes.
                pub gateways: Vec<String>,
                /// The destination hosts to which traffic is being sent.
                pub hosts: Vec<String>,
                /// An ordered list of route rules for HTTP traffic.
                pub http: Vec<HttpItem>,
                /// An ordered list of route rules for opaque TCP traffic.
                pub tcp: Vec<TcpItem>,
                pub tls: Vec<TlsItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItem {
                pub r#match: Vec<TcpItemMatchItem>,
                /// The destination to which the connection should be forwarded to.
                pub route: Vec<TcpItemRouteItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItem {
                pub r#match: Vec<TlsItemMatchItem>,
                /// The destination to which the connection should be forwarded to.
                pub route: Vec<TlsItemRouteItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Uri {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HeadersValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct QueryParamsValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WithoutHeadersValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            /// withoutHeader has the same syntax with the header, but has opposite meaning.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WithoutHeaders {
                /// withoutHeader has the same syntax with the header, but has opposite meaning.
                pub properties: std::collections::HashMap<String, WithoutHeadersValue>,
            }

            impl k8s_openapi::Resource for VirtualService {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "VirtualService";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for VirtualService {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod workload_entry {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadEntry {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: Labels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            impl k8s_openapi::Resource for WorkloadEntry {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "WorkloadEntry";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for WorkloadEntry {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod workload_group {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadGroup {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Annotations {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Health is determined by how the command that is executed exited.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Exec {
                /// Command to run.
                pub command: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpGet {
                /// Host name to connect to, defaults to the pod IP.
                pub host: String,
                /// Headers the proxy will pass on to make the request.
                pub http_headers: Vec<HttpHeadersItem>,
                /// Path to access on the HTTP server.
                pub path: String,
                /// Port on which the endpoint lives.
                pub port: i64,
                pub scheme: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpHeadersItem {
                pub name: String,
                pub value: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MetadataLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TemplateLabels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Metadata that will be used for all corresponding `WorkloadEntries`.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Metadata {
                pub annotations: Annotations,
                pub labels: MetadataLabels,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Probe {
                /// Health is determined by how the command that is executed exited.
                pub exec: Exec,
                /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
                pub failure_threshold: i32,
                pub http_get: HttpGet,
                /// Number of seconds after the container has started before readiness probes are initiated.
                pub initial_delay_seconds: i32,
                /// How often (in seconds) to perform the probe.
                pub period_seconds: i32,
                /// Minimum consecutive successes for the probe to be considered successful after having failed.
                pub success_threshold: i32,
                /// Health is determined by if the proxy is able to connect.
                pub tcp_socket: TcpSocket,
                /// Number of seconds after which the probe times out.
                pub timeout_seconds: i32,
            }

            /// Describes a collection of workload instances. See more details at: https://istio.io/docs/reference/config/networking/workload-group.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Metadata that will be used for all corresponding `WorkloadEntries`.
                pub metadata: Metadata,
                /// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
                pub probe: Probe,
                /// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
                pub template: Template,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Health is determined by if the proxy is able to connect.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpSocket {
                pub host: String,
                pub port: i64,
            }

            /// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Template {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: TemplateLabels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            impl k8s_openapi::Resource for WorkloadGroup {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1alpha3";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "WorkloadGroup";
                const VERSION: &'static str = "v1alpha3";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for WorkloadGroup {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
    pub mod v1beta1 {
        pub mod destination_rule {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct DestinationRule {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPool {
                /// HTTP connection pool settings.
                pub http: SubsetsItemTrafficPolicyConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SubsetsItemTrafficPolicyConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPool {
                /// HTTP connection pool settings.
                pub http: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPool {
                /// HTTP connection pool settings.
                pub http: SpecTrafficPolicyConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SpecTrafficPolicyConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPool {
                /// HTTP connection pool settings.
                pub http: SpecTrafficPolicyPortLevelSettingsItemConnectionPoolHttp,
                /// Settings common to both HTTP and TCP upstream connections.
                pub tcp: SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcp,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie: SubsetsItemTrafficPolicyLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash {
            /// Hash based on HTTP cookie.
            pub http_cookie: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie,
            /// Hash based on a specific HTTP header.
            pub http_header_name: String,
            /// Hash based on a specific HTTP query parameter.
            pub http_query_parameter_name: String,
            pub minimum_ring_size: i64,
            /// Hash based on the source IP address.
            pub use_source_ip: bool,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie: SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash {
                /// Hash based on HTTP cookie.
                pub http_cookie:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie,
                /// Hash based on a specific HTTP header.
                pub http_header_name: String,
                /// Hash based on a specific HTTP query parameter.
                pub http_query_parameter_name: String,
                pub minimum_ring_size: i64,
                /// Hash based on the source IP address.
                pub use_source_ip: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem {
                /// Originating locality, '/' separated, e.g.
                pub from: String,
                /// Map of upstream localities to traffic distribution weights.
                pub to: SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem {
            /// Originating locality, '/' separated, e.g.
            pub from: String,
            /// Map of upstream localities to traffic distribution weights.
            pub to: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem {
                /// Originating locality, '/' separated, e.g.
                pub from: String,
                /// Map of upstream localities to traffic distribution weights.
                pub to: SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem {
            /// Originating locality, '/' separated, e.g.
            pub from: String,
            /// Map of upstream localities to traffic distribution weights.
            pub to: SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem {
                /// Originating region.
                pub from: String,
                pub to: String,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// HTTP connection pool settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolHttp {
                /// Specify if http1.1 connection should be upgraded to http2 for the associated destination.
                pub h2_upgrade_policy: String,
                /// Maximum number of pending HTTP requests to a destination.
                pub http1_max_pending_requests: i32,
                /// Maximum number of requests to a backend.
                pub http2_max_requests: i32,
                /// The idle timeout for upstream connection pool connections.
                pub idle_timeout: String,
                /// Maximum number of requests per connection to a backend.
                pub max_requests_per_connection: i32,
                pub max_retries: i32,
                /// If set to true, client protocol will be preserved while initiating connection to backend.
                pub use_client_protocol: bool,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            /// Hash based on HTTP cookie.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHashHttpCookie {
                /// Name of the cookie.
                pub name: String,
                /// Path to set for the cookie.
                pub path: String,
                /// Lifetime of the cookie.
                pub ttl: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancer {
                pub consistent_hash: SubsetsItemTrafficPolicyLoadBalancerConsistentHash,
                pub locality_lb_setting: SubsetsItemTrafficPolicyLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancer {
                pub consistent_hash:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash,
                pub locality_lb_setting:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancer {
                pub consistent_hash: SpecTrafficPolicyLoadBalancerConsistentHash,
                pub locality_lb_setting: SpecTrafficPolicyLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            /// Settings controlling the load balancer algorithms.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancer {
                pub consistent_hash:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerConsistentHash,
                pub locality_lb_setting:
                    SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting,
                pub simple: String,
                /// Represents the warmup duration of Service.
                pub warmup_duration_secs: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSetting {
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub distribute:
                    Vec<SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem>,
                /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
                pub enabled: Option<bool>,
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub failover:
                    Vec<SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem>,
                /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
                pub failover_priority: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting {
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub distribute: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem>,
            /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
            pub enabled: Option<bool>,
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub failover: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem>,
            /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
            pub failover_priority: Vec<String>,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSetting {
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub distribute: Vec<SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItem>,
                /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
                pub enabled: Option<bool>,
                /// Optional: only one of distribute, failover or failoverPriority can be set.
                pub failover: Vec<SpecTrafficPolicyLoadBalancerLocalityLbSettingFailoverItem>,
                /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
                pub failover_priority: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSetting {
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub distribute: Vec<SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItem>,
            /// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
            pub enabled: Option<bool>,
            /// Optional: only one of distribute, failover or failoverPriority can be set.
            pub failover: Vec<SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingFailoverItem>,
            /// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
            pub failover_priority: Vec<String>,
        }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemOutlierDetection {
                /// Minimum ejection duration.
                pub base_ejection_time: String,
                /// Number of 5xx errors before a host is ejected from the connection pool.
                pub consecutive5xx_errors: Option<i64>,
                pub consecutive_errors: i32,
                /// Number of gateway errors before a host is ejected from the connection pool.
                pub consecutive_gateway_errors: Option<i64>,
                pub consecutive_local_origin_failures: Option<i64>,
                /// Time interval between ejection sweep analysis.
                pub interval: String,
                pub max_ejection_percent: i32,
                pub min_health_percent: i32,
                /// Determines whether to distinguish local origin failures from external errors.
                pub split_external_local_origin_errors: bool,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemPort {
                pub number: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemPort {
                pub number: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItem {
                pub connection_pool: SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancer,
                pub outlier_detection:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemOutlierDetection,
                pub port: SubsetsItemTrafficPolicyPortLevelSettingsItemPort,
                /// TLS related settings for connections to the upstream service.
                pub tls: SubsetsItemTrafficPolicyPortLevelSettingsItemTls,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItem {
                pub connection_pool: SpecTrafficPolicyPortLevelSettingsItemConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SpecTrafficPolicyPortLevelSettingsItemLoadBalancer,
                pub outlier_detection: SpecTrafficPolicyPortLevelSettingsItemOutlierDetection,
                pub port: SpecTrafficPolicyPortLevelSettingsItemPort,
                /// TLS related settings for connections to the upstream service.
                pub tls: SpecTrafficPolicyPortLevelSettingsItemTls,
            }

            /// Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// A list of namespaces to which this destination rule is exported.
                pub export_to: Vec<String>,
                /// The name of a service from the service registry.
                pub host: String,
                pub subsets: Vec<SubsetsItem>,
                pub traffic_policy: SpecTrafficPolicy,
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItem {
                pub labels: Labels,
                /// Name of the subset.
                pub name: String,
                /// Traffic policies that apply to this subset.
                pub traffic_policy: SubsetsItemTrafficPolicy,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive: SubsetsItemTrafficPolicyConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive:
                    SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive: SpecTrafficPolicyConnectionPoolTcpTcpKeepalive,
            }

            /// Settings common to both HTTP and TCP upstream connections.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcp {
                /// TCP connection timeout.
                pub connect_timeout: String,
                /// Maximum number of HTTP1 /TCP connections to a destination host.
                pub max_connections: i32,
                /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
                pub tcp_keepalive:
                    SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemConnectionPoolTcpTcpKeepalive {
                /// The time duration between keep-alive probes.
                pub interval: String,
                pub probes: i64,
                pub time: String,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// TLS related settings for connections to the upstream service.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyTls {
                pub ca_certificates: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub client_certificate: String,
                pub credential_name: String,
                pub insecure_skip_verify: Option<bool>,
                pub mode: String,
                /// REQUIRED if mode is `MUTUAL`.
                pub private_key: String,
                /// SNI string to present to the server during TLS handshake.
                pub sni: String,
                pub subject_alt_names: Vec<String>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo
            {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Map of upstream localities to traffic distribution weights.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyPortLevelSettingsItemLoadBalancerLocalityLbSettingDistributeItemTo {
                /// Map of upstream localities to traffic distribution weights.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Traffic policies that apply to this subset.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicy {
                pub connection_pool: SubsetsItemTrafficPolicyConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SubsetsItemTrafficPolicyLoadBalancer,
                pub outlier_detection: SubsetsItemTrafficPolicyOutlierDetection,
                /// Traffic policies specific to individual ports.
                pub port_level_settings: Vec<SubsetsItemTrafficPolicyPortLevelSettingsItem>,
                /// TLS related settings for connections to the upstream service.
                pub tls: SubsetsItemTrafficPolicyTls,
                pub tunnel: SubsetsItemTrafficPolicyTunnel,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicy {
                pub connection_pool: SpecTrafficPolicyConnectionPool,
                /// Settings controlling the load balancer algorithms.
                pub load_balancer: SpecTrafficPolicyLoadBalancer,
                pub outlier_detection: SpecTrafficPolicyOutlierDetection,
                /// Traffic policies specific to individual ports.
                pub port_level_settings: Vec<SpecTrafficPolicyPortLevelSettingsItem>,
                /// TLS related settings for connections to the upstream service.
                pub tls: SpecTrafficPolicyTls,
                pub tunnel: SpecTrafficPolicyTunnel,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SubsetsItemTrafficPolicyTunnel {
                /// Specifies which protocol to use for tunneling the downstream connection.
                pub protocol: String,
                /// Specifies a host to which the downstream connection is tunneled.
                pub target_host: String,
                /// Specifies a port to which the downstream connection is tunneled.
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecTrafficPolicyTunnel {
                /// Specifies which protocol to use for tunneling the downstream connection.
                pub protocol: String,
                /// Specifies a host to which the downstream connection is tunneled.
                pub target_host: String,
                /// Specifies a port to which the downstream connection is tunneled.
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub match_labels: MatchLabels,
            }

            impl k8s_openapi::Resource for DestinationRule {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "DestinationRule";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for DestinationRule {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod gateway {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Gateway {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Port {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ServersItem {
                pub bind: String,
                pub default_endpoint: String,
                /// One or more hosts exposed by this gateway.
                pub hosts: Vec<String>,
                /// An optional name of the server, when set must be unique across all servers.
                pub name: String,
                pub port: Port,
                /// Set of TLS related options that govern the server's behavior.
                pub tls: Tls,
            }

            /// Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub selector: Selector,
                /// A list of server specifications.
                pub servers: Vec<ServersItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of TLS related options that govern the server's behavior.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Tls {
                /// REQUIRED if mode is `MUTUAL`.
                pub ca_certificates: String,
                /// Optional: If specified, only support the specified cipher list.
                pub cipher_suites: Vec<String>,
                pub credential_name: String,
                pub https_redirect: bool,
                /// Optional: Maximum TLS protocol version.
                pub max_protocol_version: String,
                /// Optional: Minimum TLS protocol version.
                pub min_protocol_version: String,
                pub mode: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub private_key: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub server_certificate: String,
                pub subject_alt_names: Vec<String>,
                pub verify_certificate_hash: Vec<String>,
                pub verify_certificate_spki: Vec<String>,
            }

            impl k8s_openapi::Resource for Gateway {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "Gateway";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Gateway {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod proxy_config {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ProxyConfig {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            /// Additional environment variables for the proxy.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EnvironmentVariables {
                /// Additional environment variables for the proxy.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Specifies the details of the proxy image.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Image {
                /// The image type of the image.
                pub image_type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The number of worker threads to run.
                pub concurrency: Option<i64>,
                /// Additional environment variables for the proxy.
                pub environment_variables: EnvironmentVariables,
                /// Specifies the details of the proxy image.
                pub image: Image,
                /// Optional.
                pub selector: Selector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            impl k8s_openapi::Resource for ProxyConfig {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "ProxyConfig";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ProxyConfig {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod service_entry {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ServiceEntry {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EndpointsItem {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: EndpointsItemLabels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EndpointsItemLabels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelectorLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct PortsItem {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The virtual IP addresses associated with the service.
                pub addresses: Vec<String>,
                /// One or more endpoints associated with the service.
                pub endpoints: Vec<EndpointsItem>,
                /// A list of namespaces to which this service is exported.
                pub export_to: Vec<String>,
                /// The hosts associated with the ServiceEntry.
                pub hosts: Vec<String>,
                pub location: String,
                /// The ports associated with the external service.
                pub ports: Vec<PortsItem>,
                /// Service discovery mode for the hosts.
                pub resolution: String,
                pub subject_alt_names: Vec<String>,
                /// Applicable only for MESH_INTERNAL services.
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Applicable only for MESH_INTERNAL services.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub labels: WorkloadSelectorLabels,
            }

            impl k8s_openapi::Resource for ServiceEntry {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "ServiceEntry";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for ServiceEntry {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod sidecar {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Sidecar {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressItem {
                pub bind: String,
                pub capture_mode: String,
                pub hosts: Vec<String>,
                /// The port associated with the listener.
                pub port: EgressItemPort,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressProxy {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: EgressProxyPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct IngressItem {
                /// The IP to which the listener should be bound.
                pub bind: String,
                pub capture_mode: String,
                pub default_endpoint: String,
                /// The port associated with the listener.
                pub port: IngressItemPort,
                pub tls: Tls,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Configuration for the outbound traffic policy.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct OutboundTrafficPolicy {
                pub egress_proxy: EgressProxy,
                pub mode: String,
            }

            /// The port associated with the listener.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressItemPort {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// The port associated with the listener.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct IngressItemPort {
                /// Label assigned to the port.
                pub name: String,
                /// A valid non-negative integer port number.
                pub number: i64,
                /// The protocol exposed on the port.
                pub protocol: String,
                pub target_port: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct EgressProxyPort {
                pub number: i64,
            }

            /// Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub egress: Vec<EgressItem>,
                pub ingress: Vec<IngressItem>,
                /// Configuration for the outbound traffic policy.
                pub outbound_traffic_policy: OutboundTrafficPolicy,
                pub workload_selector: WorkloadSelector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Tls {
                /// REQUIRED if mode is `MUTUAL`.
                pub ca_certificates: String,
                /// Optional: If specified, only support the specified cipher list.
                pub cipher_suites: Vec<String>,
                pub credential_name: String,
                pub https_redirect: bool,
                /// Optional: Maximum TLS protocol version.
                pub max_protocol_version: String,
                /// Optional: Minimum TLS protocol version.
                pub min_protocol_version: String,
                pub mode: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub private_key: String,
                /// REQUIRED if mode is `SIMPLE` or `MUTUAL`.
                pub server_certificate: String,
                pub subject_alt_names: Vec<String>,
                pub verify_certificate_hash: Vec<String>,
                pub verify_certificate_spki: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadSelector {
                pub labels: Labels,
            }

            impl k8s_openapi::Resource for Sidecar {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "Sidecar";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Sidecar {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod virtual_service {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct VirtualService {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Abort {
                /// GRPC status code to use to abort the request.
                pub grpc_status: String,
                pub http2_error: String,
                /// HTTP status code to use to abort the Http request.
                pub http_status: i32,
                /// Percentage of requests to be aborted with the error code provided.
                pub percentage: AbortPercentage,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequestAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponseAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequestAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponseAdd {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AllowOriginsItem {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Authority {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            /// Cross-Origin Resource Sharing policy (CORS).
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct CorsPolicy {
                pub allow_credentials: Option<bool>,
                pub allow_headers: Vec<String>,
                /// List of HTTP methods allowed to access the resource.
                pub allow_methods: Vec<String>,
                /// The list of origins that are allowed to perform CORS requests.
                pub allow_origin: Vec<String>,
                /// String patterns that match allowed origins.
                pub allow_origins: Vec<AllowOriginsItem>,
                pub expose_headers: Vec<String>,
                pub max_age: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Delay {
                pub exponential_delay: String,
                /// Add a fixed delay before forwarding the request.
                pub fixed_delay: String,
                /// Percentage of requests on which the delay will be injected (0-100).
                pub percent: i32,
                /// Percentage of requests on which the delay will be injected.
                pub percentage: DelayPercentage,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Delegate {
                /// Name specifies the name of the delegate VirtualService.
                pub name: String,
                /// Namespace specifies the namespace where the delegate VirtualService resides.
                pub namespace: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: HttpItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: TcpItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItemDestination {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: TlsItemRouteItemDestinationPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            /// Fault injection policy to apply on HTTP traffic at the client side.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Fault {
                pub abort: Abort,
                pub delay: Delay,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeaders {
                pub request: HttpItemHeadersRequest,
                pub response: HttpItemHeadersResponse,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchItemHeaders {
                pub properties: std::collections::HashMap<String, HeadersValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeaders {
                pub request: RouteItemHeadersRequest,
                pub response: RouteItemHeadersResponse,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItem {
                /// Cross-Origin Resource Sharing policy (CORS).
                pub cors_policy: CorsPolicy,
                pub delegate: Delegate,
                /// Fault injection policy to apply on HTTP traffic at the client side.
                pub fault: Fault,
                pub headers: HttpItemHeaders,
                pub r#match: Vec<HttpItemMatchItem>,
                pub mirror: Mirror,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percent: Option<i64>,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percentage: MirrorPercentage,
                /// Percentage of the traffic to be mirrored by the `mirror` field.
                pub mirror_percent: Option<i64>,
                /// The name assigned to the route for debugging purposes.
                pub name: String,
                /// A HTTP rule can either redirect or forward (default) traffic.
                pub redirect: Redirect,
                /// Retry policy for HTTP requests.
                pub retries: Retries,
                /// Rewrite HTTP URIs and Authority headers.
                pub rewrite: Rewrite,
                /// A HTTP rule can either redirect or forward (default) traffic.
                pub route: Vec<HttpItemRouteItem>,
                /// Timeout for HTTP requests, default is disabled.
                pub timeout: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemMatchItem {
                pub authority: Authority,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                pub headers: MatchItemHeaders,
                /// Flag to specify whether the URI matching should be case-insensitive.
                pub ignore_uri_case: bool,
                pub method: Method,
                /// The name assigned to a match.
                pub name: String,
                /// Specifies the ports on the host that is being addressed.
                pub port: i64,
                /// Query parameters for matching.
                pub query_params: QueryParams,
                pub scheme: Scheme,
                pub source_labels: HttpItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
                pub uri: Uri,
                /// withoutHeader has the same syntax with the header, but has opposite meaning.
                pub without_headers: WithoutHeaders,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemMatchItem {
                /// IPv4 or IPv6 ip addresses of destination with optional subnet.
                pub destination_subnets: Vec<String>,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                /// Specifies the port on the host that is being addressed.
                pub port: i64,
                pub source_labels: TcpItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
                /// IPv4 or IPv6 ip address of source with optional subnet.
                pub source_subnet: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemMatchItem {
                /// IPv4 or IPv6 ip addresses of destination with optional subnet.
                pub destination_subnets: Vec<String>,
                /// Names of gateways where the rule should be applied.
                pub gateways: Vec<String>,
                /// Specifies the port on the host that is being addressed.
                pub port: i64,
                /// SNI (server name indicator) to match on.
                pub sni_hosts: Vec<String>,
                pub source_labels: TlsItemMatchItemSourceLabels,
                /// Source namespace constraining the applicability of a rule to workloads in that namespace.
                pub source_namespace: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Method {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Mirror {
                /// The name of a service from the service registry.
                pub host: String,
                /// Specifies the port on the host that is being addressed.
                pub port: MirrorPort,
                /// The name of a subset within the service.
                pub subset: String,
            }

            /// Percentage of the traffic to be mirrored by the `mirror` field.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MirrorPercentage {
                pub value: f64,
            }

            /// Percentage of requests to be aborted with the error code provided.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AbortPercentage {
                pub value: f64,
            }

            /// Percentage of requests on which the delay will be injected.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct DelayPercentage {
                pub value: f64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MirrorPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Specifies the port on the host that is being addressed.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItemDestinationPort {
                pub number: i64,
            }

            /// Query parameters for matching.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct QueryParams {
                /// Query parameters for matching.
                pub properties: std::collections::HashMap<String, QueryParamsValue>,
            }

            /// A HTTP rule can either redirect or forward (default) traffic.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Redirect {
                pub authority: String,
                pub derive_port: String,
                /// On a redirect, overwrite the port portion of the URL with this value.
                pub port: i64,
                pub redirect_code: i64,
                /// On a redirect, overwrite the scheme portion of the URL with this value.
                pub scheme: String,
                pub uri: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequest {
                pub add: HttpItemHeadersRequestAdd,
                pub remove: Vec<String>,
                pub set: HttpItemHeadersRequestSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequest {
                pub add: RouteItemHeadersRequestAdd,
                pub remove: Vec<String>,
                pub set: RouteItemHeadersRequestSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponse {
                pub add: HttpItemHeadersResponseAdd,
                pub remove: Vec<String>,
                pub set: HttpItemHeadersResponseSet,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponse {
                pub add: RouteItemHeadersResponseAdd,
                pub remove: Vec<String>,
                pub set: RouteItemHeadersResponseSet,
            }

            /// Retry policy for HTTP requests.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Retries {
                /// Number of retries to be allowed for a given request.
                pub attempts: i32,
                /// Timeout per attempt for a given request, including the initial call and any retries.
                pub per_try_timeout: String,
                /// Specifies the conditions under which retry takes place.
                pub retry_on: String,
                /// Flag to specify whether the retries should retry to other localities.
                pub retry_remote_localities: Option<bool>,
            }

            /// Rewrite HTTP URIs and Authority headers.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Rewrite {
                /// rewrite the Authority/Host header with this value.
                pub authority: String,
                pub uri: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemRouteItem {
                pub destination: HttpItemRouteItemDestination,
                pub headers: RouteItemHeaders,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemRouteItem {
                pub destination: TcpItemRouteItemDestination,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemRouteItem {
                pub destination: TlsItemRouteItemDestination,
                /// Weight specifies the relative proportion of traffic to be forwarded to the destination.
                pub weight: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Scheme {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersRequestSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemHeadersResponseSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersRequestSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RouteItemHeadersResponseSet {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItemMatchItemSourceLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// A list of namespaces to which this virtual service is exported.
                pub export_to: Vec<String>,
                /// The names of gateways and sidecars that should apply these routes.
                pub gateways: Vec<String>,
                /// The destination hosts to which traffic is being sent.
                pub hosts: Vec<String>,
                /// An ordered list of route rules for HTTP traffic.
                pub http: Vec<HttpItem>,
                /// An ordered list of route rules for opaque TCP traffic.
                pub tcp: Vec<TcpItem>,
                pub tls: Vec<TlsItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpItem {
                pub r#match: Vec<TcpItemMatchItem>,
                /// The destination to which the connection should be forwarded to.
                pub route: Vec<TcpItemRouteItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TlsItem {
                pub r#match: Vec<TlsItemMatchItem>,
                /// The destination to which the connection should be forwarded to.
                pub route: Vec<TlsItemRouteItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Uri {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HeadersValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct QueryParamsValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WithoutHeadersValue {
                pub exact: String,
                pub prefix: String,
                /// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
                pub regex: String,
            }

            /// withoutHeader has the same syntax with the header, but has opposite meaning.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WithoutHeaders {
                /// withoutHeader has the same syntax with the header, but has opposite meaning.
                pub properties: std::collections::HashMap<String, WithoutHeadersValue>,
            }

            impl k8s_openapi::Resource for VirtualService {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "VirtualService";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for VirtualService {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod workload_entry {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadEntry {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: Labels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            impl k8s_openapi::Resource for WorkloadEntry {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "WorkloadEntry";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for WorkloadEntry {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod workload_group {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadGroup {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Annotations {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Health is determined by how the command that is executed exited.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Exec {
                /// Command to run.
                pub command: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpGet {
                /// Host name to connect to, defaults to the pod IP.
                pub host: String,
                /// Headers the proxy will pass on to make the request.
                pub http_headers: Vec<HttpHeadersItem>,
                /// Path to access on the HTTP server.
                pub path: String,
                /// Port on which the endpoint lives.
                pub port: i64,
                pub scheme: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct HttpHeadersItem {
                pub name: String,
                pub value: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MetadataLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// One or more labels associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TemplateLabels {
                /// One or more labels associated with the endpoint.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Metadata that will be used for all corresponding `WorkloadEntries`.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Metadata {
                pub annotations: Annotations,
                pub labels: MetadataLabels,
            }

            /// Set of ports associated with the endpoint.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Ports {
                /// Set of ports associated with the endpoint.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Probe {
                /// Health is determined by how the command that is executed exited.
                pub exec: Exec,
                /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
                pub failure_threshold: i32,
                pub http_get: HttpGet,
                /// Number of seconds after the container has started before readiness probes are initiated.
                pub initial_delay_seconds: i32,
                /// How often (in seconds) to perform the probe.
                pub period_seconds: i32,
                /// Minimum consecutive successes for the probe to be considered successful after having failed.
                pub success_threshold: i32,
                /// Health is determined by if the proxy is able to connect.
                pub tcp_socket: TcpSocket,
                /// Number of seconds after which the probe times out.
                pub timeout_seconds: i32,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Metadata that will be used for all corresponding `WorkloadEntries`.
                pub metadata: Metadata,
                /// `ReadinessProbe` describes the configuration the user must provide for healthchecking on their workload.
                pub probe: Probe,
                /// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
                pub template: Template,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Health is determined by if the proxy is able to connect.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TcpSocket {
                pub host: String,
                pub port: i64,
            }

            /// Template to be used for the generation of `WorkloadEntry` resources that belong to this `WorkloadGroup`.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Template {
                pub address: String,
                /// One or more labels associated with the endpoint.
                pub labels: TemplateLabels,
                /// The locality associated with the endpoint.
                pub locality: String,
                pub network: String,
                /// Set of ports associated with the endpoint.
                pub ports: Ports,
                pub service_account: String,
                /// The load balancing weight associated with the endpoint.
                pub weight: i64,
            }

            impl k8s_openapi::Resource for WorkloadGroup {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "networking.istio.io/v1beta1";
                const GROUP: &'static str = "networking.istio.io";
                const KIND: &'static str = "WorkloadGroup";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for WorkloadGroup {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
}
pub mod security_istio_io {
    pub mod v1beta1 {
        pub mod authorization_policy {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AuthorizationPolicy {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct FromItem {
                /// Source specifies the source of a request.
                pub source: Source,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Operation specifies the operation of a request.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Operation {
                /// Optional.
                pub hosts: Vec<String>,
                /// Optional.
                pub methods: Vec<String>,
                /// Optional.
                pub not_hosts: Vec<String>,
                /// Optional.
                pub not_methods: Vec<String>,
                /// Optional.
                pub not_paths: Vec<String>,
                /// Optional.
                pub not_ports: Vec<String>,
                /// Optional.
                pub paths: Vec<String>,
                /// Optional.
                pub ports: Vec<String>,
            }

            /// Specifies detailed configuration of the CUSTOM action.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Provider {
                /// Specifies the name of the extension provider.
                pub name: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RulesItem {
                /// Optional.
                pub from: Vec<FromItem>,
                /// Optional.
                pub to: Vec<ToItem>,
                /// Optional.
                pub when: Vec<WhenItem>,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// Source specifies the source of a request.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Source {
                /// Optional.
                pub ip_blocks: Vec<String>,
                /// Optional.
                pub namespaces: Vec<String>,
                /// Optional.
                pub not_ip_blocks: Vec<String>,
                /// Optional.
                pub not_namespaces: Vec<String>,
                /// Optional.
                pub not_principals: Vec<String>,
                /// Optional.
                pub not_remote_ip_blocks: Vec<String>,
                /// Optional.
                pub not_request_principals: Vec<String>,
                /// Optional.
                pub principals: Vec<String>,
                /// Optional.
                pub remote_ip_blocks: Vec<String>,
                /// Optional.
                pub request_principals: Vec<String>,
            }

            /// Configuration for access control on workloads. See more details at: https://istio.io/docs/reference/config/security/authorization-policy.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Optional.
                pub action: String,
                /// Specifies detailed configuration of the CUSTOM action.
                pub provider: Provider,
                /// Optional.
                pub rules: Vec<RulesItem>,
                /// Optional.
                pub selector: Selector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct ToItem {
                /// Operation specifies the operation of a request.
                pub operation: Operation,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct WhenItem {
                /// The name of an Istio attribute.
                pub key: String,
                /// Optional.
                pub not_values: Vec<String>,
                /// Optional.
                pub values: Vec<String>,
            }

            impl k8s_openapi::Resource for AuthorizationPolicy {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "security.istio.io/v1beta1";
                const GROUP: &'static str = "security.istio.io";
                const KIND: &'static str = "AuthorizationPolicy";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for AuthorizationPolicy {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod peer_authentication {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct PeerAuthentication {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Mutual TLS settings for workload.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Mtls {
                /// Defines the mTLS mode used for peer authentication.
                pub mode: String,
            }

            /// Port specific mutual TLS settings.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct PortLevelMtls {
                /// Port specific mutual TLS settings.
                pub properties: std::collections::HashMap<String, Value>,
            }

            /// The selector determines the workloads to apply the ChannelAuthentication on.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// PeerAuthentication defines how traffic will be tunneled (or not) to the sidecar.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Mutual TLS settings for workload.
                pub mtls: Mtls,
                /// Port specific mutual TLS settings.
                pub port_level_mtls: PortLevelMtls,
                /// The selector determines the workloads to apply the ChannelAuthentication on.
                pub selector: Selector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Value {
                /// Defines the mTLS mode used for peer authentication.
                pub mode: String,
            }

            impl k8s_openapi::Resource for PeerAuthentication {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "security.istio.io/v1beta1";
                const GROUP: &'static str = "security.istio.io";
                const KIND: &'static str = "PeerAuthentication";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for PeerAuthentication {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
        pub mod request_authentication {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct RequestAuthentication {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct FromHeadersItem {
                /// The HTTP header name.
                pub name: String,
                /// The prefix that should be stripped before decoding the token.
                pub prefix: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct JwtRulesItem {
                pub audiences: Vec<String>,
                /// If set to true, the original token will be kept for the upstream request.
                pub forward_original_token: bool,
                /// List of header locations from which JWT is expected.
                pub from_headers: Vec<FromHeadersItem>,
                /// List of query parameters from which JWT is expected.
                pub from_params: Vec<String>,
                /// Identifies the issuer that issued the JWT.
                pub issuer: String,
                /// JSON Web Key Set of public keys to validate signature of the JWT.
                pub jwks: String,
                pub jwks_uri: String,
                pub jwks_uri: String,
                pub output_payload_to_header: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// RequestAuthentication defines what request authentication methods are supported by a workload.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Define the list of JWTs that can be validated at the selected workloads' proxy.
                pub jwt_rules: Vec<JwtRulesItem>,
                /// Optional.
                pub selector: Selector,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            impl k8s_openapi::Resource for RequestAuthentication {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "security.istio.io/v1beta1";
                const GROUP: &'static str = "security.istio.io";
                const KIND: &'static str = "RequestAuthentication";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for RequestAuthentication {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
}
pub mod telemetry_istio_io {
    pub mod v1alpha1 {
        pub mod telemetry {
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Telemetry {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessLoggingItem {
                /// Controls logging.
                pub disabled: Option<bool>,
                /// Optional.
                pub filter: Filter,
                /// Allows tailoring of logging behavior to specific conditions.
                pub r#match: AccessLoggingItemMatch,
                /// Optional.
                pub providers: Vec<AccessLoggingItemProvidersItem>,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct CustomTags {
                /// Optional.
                pub properties: std::collections::HashMap<String, CustomTagsValue>,
            }

            /// Environment adds the value of an environment variable to each span.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Environment {
                /// Optional.
                pub default_value: String,
                /// Name of the environment variable from which to extract the tag value.
                pub name: String,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Filter {
                /// CEL expression for selecting when requests/connections should be logged.
                pub expression: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Header {
                /// Optional.
                pub default_value: String,
                /// Name of the header from which to extract the tag value.
                pub name: String,
            }

            /// Literal adds the same, hard-coded value to each span.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Literal {
                /// The tag value to use.
                pub value: String,
            }

            /// Allows tailoring of logging behavior to specific conditions.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessLoggingItemMatch {
                pub mode: String,
            }

            /// Match allows provides the scope of the override.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct OverridesItemMatch {
                /// Allows free-form specification of a metric.
                pub custom_metric: String,
                /// One of the well-known Istio Standard Metrics.
                pub metric: String,
                pub mode: String,
            }

            /// Allows tailoring of behavior to specific conditions.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TracingItemMatch {
                pub mode: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MatchLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MetricsItem {
                /// Optional.
                pub overrides: Vec<OverridesItem>,
                /// Optional.
                pub providers: Vec<MetricsItemProvidersItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct OverridesItem {
                /// Optional.
                pub disabled: Option<bool>,
                /// Match allows provides the scope of the override.
                pub r#match: OverridesItemMatch,
                /// Optional.
                pub tag_overrides: TagOverrides,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct AccessLoggingItemProvidersItem {
                /// Required.
                pub name: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct MetricsItemProvidersItem {
                /// Required.
                pub name: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TracingItemProvidersItem {
                /// Required.
                pub name: String,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Selector {
                pub match_labels: MatchLabels,
            }

            /// Telemetry configuration for workloads. See more details at: https://istio.io/docs/reference/config/telemetry.html
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// Optional.
                pub access_logging: Vec<AccessLoggingItem>,
                /// Optional.
                pub metrics: Vec<MetricsItem>,
                /// Optional.
                pub selector: Selector,
                /// Optional.
                pub tracing: Vec<TracingItem>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// Optional.
            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TagOverrides {
                /// Optional.
                pub properties: std::collections::HashMap<String, TagOverridesValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TracingItem {
                /// Optional.
                pub custom_tags: CustomTags,
                /// Controls span reporting.
                pub disable_span_reporting: Option<bool>,
                /// Allows tailoring of behavior to specific conditions.
                pub r#match: TracingItemMatch,
                /// Optional.
                pub providers: Vec<TracingItemProvidersItem>,
                pub random_sampling_percentage: Option<f64>,
                pub use_request_id_for_trace_sampling: Option<bool>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct TagOverridesValue {
                /// Operation controls whether or not to update/add a tag, or to remove it.
                pub operation: String,
                /// Value is only considered if the operation is `UPSERT`.
                pub value: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Debug)]
            #[serde(rename_all = "camelCase")]
            pub struct CustomTagsValue {
                /// Environment adds the value of an environment variable to each span.
                pub environment: Environment,
                pub header: Header,
                /// Literal adds the same, hard-coded value to each span.
                pub literal: Literal,
            }

            impl k8s_openapi::Resource for Telemetry {
                type Scope = k8s_openapi::ClusterResourceScope;

                const API_VERSION: &'static str = "telemetry.istio.io/v1alpha1";
                const GROUP: &'static str = "telemetry.istio.io";
                const KIND: &'static str = "Telemetry";
                const VERSION: &'static str = "v1alpha1";
                const URL_PATH_SEGMENT: &'static str = "TODO";
            }

            impl k8s_openapi::Metadata for Telemetry {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }
        }
    }
}
