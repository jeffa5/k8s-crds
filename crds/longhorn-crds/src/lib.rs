// Generated by:
// target/debug/k8s-crds-codegen

pub mod longhorn_io {
    pub mod v1beta1 {
        pub mod backing_image {
            /// BackingImage is where Longhorn stores backing image object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImage {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for BackingImage {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImage";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImage {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImage {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImage", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod backing_image_data_source {
            /// BackingImageDataSource is where Longhorn stores backing image data source object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImageDataSource {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for BackingImageDataSource {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImageDataSource";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImageDataSource {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImageDataSource {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImageDataSource", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod backing_image_manager {
            /// BackingImageManager is where Longhorn stores backing image manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImageManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for BackingImageManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImageManager";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImageManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImageManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImageManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod backup {
            /// Backup is where Longhorn stores backup object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Backup {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for Backup {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Backup";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Backup {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Backup {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Backup", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod backup_target {
            /// BackupTarget is where Longhorn stores backup target object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackupTarget {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for BackupTarget {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackupTarget";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackupTarget {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackupTarget {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackupTarget", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod backup_volume {
            /// BackupVolume is where Longhorn stores backup volume object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackupVolume {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for BackupVolume {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackupVolume";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackupVolume {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackupVolume {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackupVolume", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod engine {
            /// Engine is where Longhorn stores engine object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Engine {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for Engine {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Engine";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Engine {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Engine {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Engine", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod engine_image {
            /// EngineImage is where Longhorn stores engine image object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct EngineImage {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for EngineImage {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "EngineImage";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for EngineImage {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for EngineImage {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("EngineImage", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod instance_manager {
            /// InstanceManager is where Longhorn stores instance manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct InstanceManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for InstanceManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "InstanceManager";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for InstanceManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for InstanceManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("InstanceManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod node {
            /// Node is where Longhorn stores Longhorn node object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Node {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for Node {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Node";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Node {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Node {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Node", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod recurring_job {
            /// RecurringJob is where Longhorn stores recurring job object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct RecurringJob {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for RecurringJob {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "RecurringJob";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for RecurringJob {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for RecurringJob {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("RecurringJob", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod replica {
            /// Replica is where Longhorn stores replica object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Replica {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for Replica {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Replica";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Replica {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Replica {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Replica", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod setting {
            /// Setting is where Longhorn stores setting object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Setting {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub value: String,
            }

            impl k8s_openapi::Resource for Setting {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Setting";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Setting {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Setting {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Setting", 4)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("value", &self.value)?;
                    state.end()
                }
            }
        }
        pub mod share_manager {
            /// ShareManager is where Longhorn stores share manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct ShareManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for ShareManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "ShareManager";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for ShareManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ShareManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ShareManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
        pub mod volume {
            /// Volume is where Longhorn stores volume object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Volume {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: serde_json::Map<String, serde_json::Value>,
                pub status: serde_json::Map<String, serde_json::Value>,
            }

            impl k8s_openapi::Resource for Volume {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta1";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Volume";
                const VERSION: &'static str = "v1beta1";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Volume {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Volume {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Volume", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }
        }
    }
    pub mod v1beta2 {
        pub mod backing_image {
            /// BackingImage is where Longhorn stores backing image object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImage {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for BackingImage {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImage";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImage {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImage {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImage", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// Deprecated: Replaced by field `Progress` in `DiskFileStatusMap`.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskDownloadProgressMap {
                /// Deprecated: Replaced by field `Progress` in `DiskFileStatusMap`.
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// Deprecated: Replaced by field `State` in `DiskFileStatusMap`.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskDownloadStateMap {
                /// Deprecated: Replaced by field `State` in `DiskFileStatusMap`.
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskFileStatusMap {
                pub properties: std::collections::HashMap<String, Value>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskLastRefAtMap {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Disks {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SourceParameters {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// BackingImageSpec defines the desired state of the Longhorn backing image
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub checksum: String,
                pub disks: Disks,
                /// Deprecated: This kind of info will be included in the related BackingImageDataSource.
                pub image_u_r_l: String,
                pub source_parameters: SourceParameters,
                pub source_type: String,
            }

            /// BackingImageStatus defines the observed state of the Longhorn backing image status
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub checksum: String,
                /// Deprecated: Replaced by field `Progress` in `DiskFileStatusMap`.
                pub disk_download_progress_map: Option<DiskDownloadProgressMap>,
                /// Deprecated: Replaced by field `State` in `DiskFileStatusMap`.
                pub disk_download_state_map: Option<DiskDownloadStateMap>,
                pub disk_file_status_map: Option<DiskFileStatusMap>,
                pub disk_last_ref_at_map: Option<DiskLastRefAtMap>,
                pub owner_i_d: String,
                pub size: i64,
                pub uuid: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Value {
                pub last_state_transition_time: String,
                pub message: String,
                pub progress: i64,
                pub state: String,
            }
        }
        pub mod backing_image_data_source {
            /// BackingImageDataSource is where Longhorn stores backing image data source object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImageDataSource {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for BackingImageDataSource {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImageDataSource";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImageDataSource {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImageDataSource {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImageDataSource", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Parameters {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RunningParameters {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub checksum: String,
                pub disk_path: String,
                pub disk_u_u_i_d: String,
                pub file_transferred: bool,
                pub node_i_d: String,
                pub parameters: Parameters,
                pub source_type: String,
                pub uuid: String,
            }

            /// BackingImageDataSourceStatus defines the observed state of the Longhorn backing image data source
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub checksum: String,
                pub current_state: String,
                pub ip: String,
                pub message: String,
                pub owner_i_d: String,
                pub progress: i64,
                pub running_parameters: Option<RunningParameters>,
                pub size: i64,
                pub storage_i_p: String,
            }
        }
        pub mod backing_image_manager {
            /// BackingImageManager is where Longhorn stores backing image manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackingImageManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for BackingImageManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackingImageManager";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackingImageManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackingImageManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackingImageManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct BackingImageFileMap {
                pub properties: std::collections::HashMap<String, Value>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct BackingImages {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub backing_images: BackingImages,
                pub disk_path: String,
                pub disk_u_u_i_d: String,
                pub image: String,
                pub node_i_d: String,
            }

            /// BackingImageManagerStatus defines the observed state of the Longhorn backing image manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub api_min_version: i64,
                pub api_version: i64,
                pub backing_image_file_map: Option<BackingImageFileMap>,
                pub current_state: String,
                pub ip: String,
                pub owner_i_d: String,
                pub storage_i_p: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Value {
                pub current_checksum: String,
                /// Deprecated: This field is useless.
                pub directory: String,
                /// Deprecated: This field is renamed to `Progress`.
                pub download_progress: i64,
                pub message: String,
                pub name: String,
                pub progress: i64,
                pub sender_manager_address: String,
                pub sending_reference: i64,
                pub size: i64,
                pub state: String,
                /// Deprecated: This field is useless now. The manager of backing image files doesn't care if a file is downloaded and how.
                pub url: String,
                pub uuid: String,
            }
        }
        pub mod backup {
            /// Backup is where Longhorn stores backup object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Backup {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Backup {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Backup";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Backup {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Backup {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Backup", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// The labels of snapshot backup.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecLabels {
                /// The labels of snapshot backup.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The labels of snapshot backup.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct StatusLabels {
                /// The labels of snapshot backup.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The error messages when calling longhorn engine on listing or inspecting backups.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Messages {
                /// The error messages when calling longhorn engine on listing or inspecting backups.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// BackupSpec defines the desired state of the Longhorn backup
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The labels of snapshot backup.
                pub labels: SpecLabels,
                /// The snapshot name.
                pub snapshot_name: String,
                /// The time to request run sync the remote backup.
                pub sync_requested_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
            }

            /// BackupStatus defines the observed state of the Longhorn backup
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// The snapshot backup upload finished time.
                pub backup_created_at: String,
                /// The error message when taking the snapshot backup.
                pub error: String,
                /// The labels of snapshot backup.
                pub labels: Option<StatusLabels>,
                /// The last time that the backup was synced with the remote backup target.
                pub last_synced_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
                /// The error messages when calling longhorn engine on listing or inspecting backups.
                pub messages: Option<Messages>,
                /// The node ID on which the controller is responsible to reconcile this backup CR.
                pub owner_i_d: String,
                /// The snapshot backup progress.
                pub progress: i64,
                /// The address of the replica that runs snapshot backup.
                pub replica_address: String,
                /// The snapshot size.
                pub size: String,
                /// The snapshot creation time.
                pub snapshot_created_at: String,
                /// The snapshot name.
                pub snapshot_name: String,
                /// The backup creation state. Can be "", "InProgress", "Completed", "Error", "Unknown".
                pub state: String,
                /// The snapshot backup URL.
                pub url: String,
                /// The volume's backing image name.
                pub volume_backing_image_name: String,
                /// The volume creation time.
                pub volume_created: String,
                /// The volume name.
                pub volume_name: String,
                /// The volume size.
                pub volume_size: String,
            }
        }
        pub mod backup_target {
            /// BackupTarget is where Longhorn stores backup target object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackupTarget {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for BackupTarget {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackupTarget";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackupTarget {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackupTarget {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackupTarget", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            /// BackupTargetSpec defines the desired state of the Longhorn backup target
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The backup target URL.
                pub backup_target_u_r_l: String,
                /// The backup target credential secret.
                pub credential_secret: String,
                /// The interval that the cluster needs to run sync with the backup target.
                pub poll_interval: String,
                /// The time to request run sync the remote backup target.
                pub sync_requested_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
            }

            /// BackupTargetStatus defines the observed state of the Longhorn backup target
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// Available indicates if the remote backup target is available or not.
                pub available: bool,
                /// Records the reason on why the backup target is unavailable.
                pub conditions: Option<Vec<ConditionsItem>>,
                /// The last time that the controller synced with the remote backup target.
                pub last_synced_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
                /// The node ID on which the controller is responsible to reconcile this backup target CR.
                pub owner_i_d: String,
            }
        }
        pub mod backup_volume {
            /// BackupVolume is where Longhorn stores backup volume object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct BackupVolume {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for BackupVolume {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "BackupVolume";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for BackupVolume {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for BackupVolume {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("BackupVolume", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// The backup volume labels.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                /// The backup volume labels.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// The error messages when call longhorn engine on list or inspect backup volumes.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Messages {
                /// The error messages when call longhorn engine on list or inspect backup volumes.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// BackupVolumeSpec defines the desired state of the Longhorn backup volume
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The time to request run sync the remote backup volume.
                pub sync_requested_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
            }

            /// BackupVolumeStatus defines the observed state of the Longhorn backup volume
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// the backing image checksum.
                pub backing_image_checksum: String,
                /// The backing image name.
                pub backing_image_name: String,
                /// The backup volume creation time.
                pub created_at: String,
                /// The backup volume block count.
                pub data_stored: String,
                /// The backup volume labels.
                pub labels: Option<Labels>,
                /// The latest volume backup time.
                pub last_backup_at: String,
                /// The latest volume backup name.
                pub last_backup_name: String,
                /// The backup volume config last modification time.
                pub last_modification_time:
                    Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
                /// The last time that the backup volume was synced into the cluster.
                pub last_synced_at: Option<k8s_openapi::apimachinery::pkg::apis::meta::v1::Time>,
                /// The error messages when call longhorn engine on list or inspect backup volumes.
                pub messages: Option<Messages>,
                /// The node ID on which the controller is responsible to reconcile this backup volume CR.
                pub owner_i_d: String,
                /// The backup volume size.
                pub size: String,
            }
        }
        pub mod engine {
            /// Engine is where Longhorn stores engine object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Engine {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Engine {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Engine";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Engine {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Engine {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Engine", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct BackupStatus {
                pub properties: std::collections::HashMap<String, BackupStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Children {
                pub properties: std::collections::HashMap<String, bool>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CloneStatus {
                pub properties: std::collections::HashMap<String, CloneStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CurrentReplicaAddressMap {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PurgeStatus {
                pub properties: std::collections::HashMap<String, PurgeStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RebuildStatus {
                pub properties: std::collections::HashMap<String, RebuildStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ReplicaAddressMap {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ReplicaModeMap {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RestoreStatus {
                pub properties: std::collections::HashMap<String, RestoreStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Snapshots {
                pub properties: std::collections::HashMap<String, SnapshotsValue>,
            }

            /// EngineSpec defines the desired state of the Longhorn engine
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub active: bool,
                pub backup_volume: String,
                pub desire_state: String,
                pub disable_frontend: bool,
                pub engine_image: String,
                pub frontend: String,
                pub log_requested: bool,
                pub node_i_d: String,
                pub replica_address_map: ReplicaAddressMap,
                pub requested_backup_restore: String,
                pub requested_data_source: String,
                pub revision_counter_disabled: bool,
                pub salvage_requested: bool,
                pub upgraded_replica_address_map: UpgradedReplicaAddressMap,
                pub volume_name: String,
                pub volume_size: String,
            }

            /// EngineStatus defines the observed state of the Longhorn engine
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub backup_status: Option<BackupStatus>,
                pub clone_status: Option<CloneStatus>,
                pub current_image: String,
                pub current_replica_address_map: Option<CurrentReplicaAddressMap>,
                pub current_size: String,
                pub current_state: String,
                pub endpoint: String,
                pub instance_manager_name: String,
                pub ip: String,
                pub is_expanding: bool,
                pub last_expansion_error: String,
                pub last_expansion_failed_at: String,
                pub last_restored_backup: String,
                pub log_fetched: bool,
                pub owner_i_d: String,
                pub port: i64,
                pub purge_status: Option<PurgeStatus>,
                pub rebuild_status: Option<RebuildStatus>,
                pub replica_mode_map: Option<ReplicaModeMap>,
                pub restore_status: Option<RestoreStatus>,
                pub salvage_executed: bool,
                pub snapshots: Option<Snapshots>,
                pub snapshots_error: String,
                pub started: bool,
                pub storage_i_p: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct UpgradedReplicaAddressMap {
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct BackupStatusValue {
                pub backup_u_r_l: String,
                pub error: String,
                pub progress: i64,
                pub replica_address: String,
                pub snapshot_name: String,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CloneStatusValue {
                pub error: String,
                pub from_replica_address: String,
                pub is_cloning: bool,
                pub progress: i64,
                pub snapshot_name: String,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct PurgeStatusValue {
                pub error: String,
                pub is_purging: bool,
                pub progress: i64,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RebuildStatusValue {
                pub error: String,
                pub from_replica_address: String,
                pub is_rebuilding: bool,
                pub progress: i64,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RestoreStatusValue {
                pub backup_u_r_l: String,
                pub current_restoring_backup: String,
                pub error: String,
                pub filename: String,
                pub is_restoring: bool,
                pub last_restored: String,
                pub progress: i64,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SnapshotsValue {
                pub children: Option<Children>,
                pub created: String,
                pub labels: Option<Labels>,
                pub name: String,
                pub parent: String,
                pub removed: bool,
                pub size: String,
                pub usercreated: bool,
            }
        }
        pub mod engine_image {
            /// EngineImage is where Longhorn stores engine image object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct EngineImage {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for EngineImage {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "EngineImage";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for EngineImage {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for EngineImage {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("EngineImage", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct NodeDeploymentMap {
                pub properties: std::collections::HashMap<String, bool>,
            }

            /// EngineImageSpec defines the desired state of the Longhorn engine image
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub image: String,
            }

            /// EngineImageStatus defines the observed state of the Longhorn engine image
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub build_date: String,
                pub cli_a_p_i_min_version: i64,
                pub cli_a_p_i_version: i64,
                pub conditions: Option<Vec<ConditionsItem>>,
                pub controller_a_p_i_min_version: i64,
                pub controller_a_p_i_version: i64,
                pub data_format_min_version: i64,
                pub data_format_version: i64,
                pub git_commit: String,
                pub no_ref_since: String,
                pub node_deployment_map: Option<NodeDeploymentMap>,
                pub owner_i_d: String,
                pub ref_count: i64,
                pub state: String,
                pub version: String,
            }
        }
        pub mod instance_manager {
            /// InstanceManager is where Longhorn stores instance manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct InstanceManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for InstanceManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "InstanceManager";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for InstanceManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for InstanceManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("InstanceManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Instances {
                pub properties: std::collections::HashMap<String, Value>,
            }

            /// InstanceManagerSpec defines the desired state of the Longhorn instancer manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// TODO: deprecate this field
                pub engine_image: String,
                pub image: String,
                pub node_i_d: String,
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ValueSpec {
                pub name: String,
            }

            /// InstanceManagerStatus defines the observed state of the Longhorn instance manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub api_min_version: i64,
                pub api_version: i64,
                pub current_state: String,
                pub instances: Option<Instances>,
                pub ip: String,
                pub owner_i_d: String,
                pub proxy_api_min_version: i64,
                pub proxy_api_version: i64,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ValueStatus {
                pub endpoint: String,
                pub error_msg: String,
                pub listen: String,
                pub port_end: i32,
                pub port_start: i32,
                pub resource_version: i64,
                pub state: String,
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Value {
                pub spec: ValueSpec,
                pub status: ValueStatus,
            }
        }
        pub mod node {
            /// Node is where Longhorn stores Longhorn node object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Node {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Node {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Node";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Node {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Node {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Node", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct StatusConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ValueConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskStatus {
                pub properties: std::collections::HashMap<String, DiskStatusValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Disks {
                pub properties: std::collections::HashMap<String, DisksValue>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ScheduledReplica {
                pub properties: std::collections::HashMap<String, i64>,
            }

            /// NodeSpec defines the desired state of the Longhorn node
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub allow_scheduling: bool,
                pub disks: Disks,
                pub engine_manager_c_p_u_request: i64,
                pub eviction_requested: bool,
                pub name: String,
                pub replica_manager_c_p_u_request: i64,
                pub tags: Vec<String>,
            }

            /// NodeStatus defines the observed state of the Longhorn node
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Option<Vec<StatusConditionsItem>>,
                pub disk_status: Option<DiskStatus>,
                pub region: String,
                pub zone: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DisksValue {
                pub allow_scheduling: bool,
                pub eviction_requested: bool,
                pub path: String,
                pub storage_reserved: i64,
                pub tags: Vec<String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct DiskStatusValue {
                pub conditions: Option<Vec<ValueConditionsItem>>,
                pub disk_u_u_i_d: String,
                pub scheduled_replica: Option<ScheduledReplica>,
                pub storage_available: i64,
                pub storage_maximum: i64,
                pub storage_scheduled: i64,
            }
        }
        pub mod orphan {
            /// Orphan is where Longhorn stores orphan object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Orphan {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Orphan {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Orphan";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Orphan {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Orphan {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Orphan", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            /// The parameters of the orphaned data
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Parameters {
                /// The parameters of the orphaned data
                pub properties: std::collections::HashMap<String, String>,
            }

            /// OrphanSpec defines the desired state of the Longhorn orphaned data
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The node ID on which the controller is responsible to reconcile this orphan CR.
                pub node_i_d: String,
                /// The type of the orphaned data. Can be "replica".
                pub orphan_type: String,
                /// The parameters of the orphaned data
                pub parameters: Parameters,
            }

            /// OrphanStatus defines the observed state of the Longhorn orphaned data
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub conditions: Option<Vec<ConditionsItem>>,
                pub owner_i_d: String,
            }
        }
        pub mod recurring_job {
            /// RecurringJob is where Longhorn stores recurring job object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct RecurringJob {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for RecurringJob {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "RecurringJob";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for RecurringJob {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for RecurringJob {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("RecurringJob", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// The label of the snapshot/backup.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                /// The label of the snapshot/backup.
                pub properties: std::collections::HashMap<String, String>,
            }

            /// RecurringJobSpec defines the desired state of the Longhorn recurring job
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// The concurrency of taking the snapshot/backup.
                pub concurrency: i64,
                /// The cron setting.
                pub cron: String,
                /// The recurring job group.
                pub groups: Vec<String>,
                /// The label of the snapshot/backup.
                pub labels: Labels,
                /// The recurring job name.
                pub name: String,
                /// The retain count of the snapshot/backup.
                pub retain: i64,
                /// The recurring job type. Can be "snapshot" or "backup".
                pub task: String,
            }

            /// RecurringJobStatus defines the observed state of the Longhorn recurring job
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                /// The owner ID which is responsible to reconcile this recurring job CR.
                pub owner_i_d: String,
            }
        }
        pub mod replica {
            /// Replica is where Longhorn stores replica object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Replica {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Replica {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Replica";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Replica {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Replica {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Replica", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// ReplicaSpec defines the desired state of the Longhorn replica
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub active: bool,
                pub backing_image: String,
                /// Deprecated. Rename to BackingImage
                pub base_image: String,
                pub data_directory_name: String,
                /// Deprecated
                pub data_path: String,
                pub desire_state: String,
                pub disk_i_d: String,
                pub disk_path: String,
                pub engine_image: String,
                pub engine_name: String,
                pub failed_at: String,
                pub hard_node_affinity: String,
                pub healthy_at: String,
                pub log_requested: bool,
                pub node_i_d: String,
                pub rebuild_retry_count: i64,
                pub revision_counter_disabled: bool,
                pub salvage_requested: bool,
                pub volume_name: String,
                pub volume_size: String,
            }

            /// ReplicaStatus defines the observed state of the Longhorn replica
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub current_image: String,
                pub current_state: String,
                pub eviction_requested: bool,
                pub instance_manager_name: String,
                pub ip: String,
                pub log_fetched: bool,
                pub owner_i_d: String,
                pub port: i64,
                pub salvage_executed: bool,
                pub started: bool,
                pub storage_i_p: String,
            }
        }
        pub mod setting {
            /// Setting is where Longhorn stores setting object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Setting {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub value: String,
            }

            impl k8s_openapi::Resource for Setting {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Setting";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Setting {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Setting {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Setting", 4)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("value", &self.value)?;
                    state.end()
                }
            }
        }
        pub mod share_manager {
            /// ShareManager is where Longhorn stores share manager object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct ShareManager {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for ShareManager {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "ShareManager";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for ShareManager {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for ShareManager {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("ShareManager", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            /// ShareManagerSpec defines the desired state of the Longhorn share manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub image: String,
            }

            /// ShareManagerStatus defines the observed state of the Longhorn share manager
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub endpoint: String,
                pub owner_i_d: String,
                pub state: String,
            }
        }
        pub mod snapshot {
            /// Snapshot is the Schema for the snapshots API
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Snapshot {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Snapshot {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Snapshot";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Snapshot {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Snapshot {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Snapshot", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Children {
                pub properties: std::collections::HashMap<String, bool>,
            }

            /// The labels of snapshot
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct SpecLabels {
                /// The labels of snapshot
                pub properties: std::collections::HashMap<String, String>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct StatusLabels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// SnapshotSpec defines the desired state of Longhorn Snapshot
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                /// require creating a new snapshot
                pub create_snapshot: bool,
                /// The labels of snapshot
                pub labels: Option<SpecLabels>,
                /// the volume that this snapshot belongs to. This field is immutable after creation. Required
                pub volume: String,
            }

            /// SnapshotStatus defines the observed state of Longhorn Snapshot
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub children: Option<Children>,
                pub creation_time: String,
                pub error: String,
                pub labels: Option<StatusLabels>,
                pub mark_removed: bool,
                pub owner_i_d: String,
                pub parent: String,
                pub ready_to_use: bool,
                pub restore_size: i64,
                pub size: i64,
                pub user_created: bool,
            }
        }
        pub mod volume {
            /// Volume is where Longhorn stores volume object.
            #[derive(serde::Deserialize, Clone, Debug, PartialEq)]
            pub struct Volume {
                pub metadata: k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta,
                pub spec: Spec,
                pub status: Status,
            }

            impl k8s_openapi::Resource for Volume {
                type Scope = k8s_openapi::NamespaceResourceScope;

                const API_VERSION: &'static str = "longhorn.io/v1beta2";
                const GROUP: &'static str = "longhorn.io";
                const KIND: &'static str = "Volume";
                const VERSION: &'static str = "v1beta2";
                const URL_PATH_SEGMENT: &'static str = "";
            }

            impl k8s_openapi::Metadata for Volume {
                type Ty = k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;

                fn metadata(&self) -> &<Self as k8s_openapi::Metadata>::Ty {
                    &self.metadata
                }

                fn metadata_mut(&mut self) -> &mut <Self as k8s_openapi::Metadata>::Ty {
                    &mut self.metadata
                }
            }

            impl serde::Serialize for Volume {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    use serde::ser::SerializeStruct;
                    let mut state = serializer.serialize_struct("Volume", 5)?;
                    state.serialize_field(
                        "apiVersion",
                        <Self as k8s_openapi::Resource>::API_VERSION,
                    )?;
                    state.serialize_field("kind", <Self as k8s_openapi::Resource>::KIND)?;
                    state.serialize_field("metadata", &self.metadata)?;
                    state.serialize_field("spec", &self.spec)?;
                    state.serialize_field("status", &self.status)?;
                    state.end()
                }
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct CloneStatus {
                pub snapshot: String,
                pub source_volume: String,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct ConditionsItem {
                /// Last time we probed the condition.
                pub last_probe_time: String,
                /// Last time the condition transitioned from one status to another.
                pub last_transition_time: String,
                /// Human-readable message indicating details about last transition.
                pub message: String,
                /// Unique, one-word, CamelCase reason for the condition's last transition.
                pub reason: String,
                /// Status is the status of the condition. Can be True, False, Unknown.
                pub status: String,
                /// Type is the type of the condition.
                pub r#type: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct KubernetesStatus {
                pub last_p_v_c_ref_at: String,
                pub last_pod_ref_at: String,
                /// determine if PVC/Namespace is history or not
                pub namespace: String,
                pub pv_name: String,
                pub pv_status: String,
                pub pvc_name: String,
                /// determine if Pod/Workload is history or not
                pub workloads_status: Option<Vec<WorkloadsStatusItem>>,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Labels {
                pub properties: std::collections::HashMap<String, String>,
            }

            /// VolumeRecurringJobSpec is a deprecated struct. TODO: Should be removed when recurringJobs gets removed from the volume       spec.
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct RecurringJobsItem {
                pub concurrency: i64,
                pub cron: String,
                pub groups: Vec<String>,
                pub labels: Labels,
                pub name: String,
                pub retain: i64,
                pub task: String,
            }

            /// VolumeSpec defines the desired state of the Longhorn volume
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Spec {
                pub standby: bool,
                pub access_mode: String,
                pub backing_image: String,
                /// Deprecated. Rename to BackingImage
                pub base_image: String,
                pub data_locality: String,
                pub data_source: String,
                pub disable_frontend: bool,
                pub disk_selector: Vec<String>,
                pub encrypted: bool,
                pub engine_image: String,
                pub from_backup: String,
                pub frontend: String,
                pub last_attached_by: String,
                pub migratable: bool,
                pub migration_node_i_d: String,
                pub node_i_d: String,
                pub node_selector: Vec<String>,
                pub number_of_replicas: i64,
                /// Deprecated. Replaced by a separate resource named "RecurringJob"
                pub recurring_jobs: Vec<RecurringJobsItem>,
                pub replica_auto_balance: String,
                pub revision_counter_disabled: bool,
                pub size: String,
                pub stale_replica_timeout: i64,
            }

            /// VolumeStatus defines the observed state of the Longhorn volume
            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct Status {
                pub actual_size: i64,
                pub clone_status: CloneStatus,
                pub conditions: Option<Vec<ConditionsItem>>,
                pub current_image: String,
                pub current_node_i_d: String,
                pub expansion_required: bool,
                pub frontend_disabled: bool,
                pub is_standby: bool,
                pub kubernetes_status: KubernetesStatus,
                pub last_backup: String,
                pub last_backup_at: String,
                pub last_degraded_at: String,
                pub owner_i_d: String,
                pub pending_node_i_d: String,
                pub remount_requested_at: String,
                pub restore_initiated: bool,
                pub restore_required: bool,
                pub robustness: String,
                pub share_endpoint: String,
                pub share_state: String,
                pub state: String,
            }

            #[derive(serde::Serialize, serde::Deserialize, Clone, Debug, PartialEq)]
            #[serde(rename_all = "camelCase")]
            pub struct WorkloadsStatusItem {
                pub pod_name: String,
                pub pod_status: String,
                pub workload_name: String,
                pub workload_type: String,
            }
        }
    }
}
